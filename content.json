{"meta":{"title":"神奇的战士","subtitle":"🍉 Start with one, then make many.","description":"📚 书写是为了更好地思考","author":"神奇的战士","url":"http://thinkhard.tech"},"pages":[{"title":"about","date":"2019-04-04T10:10:23.776Z","updated":"2019-04-04T10:10:23.776Z","comments":true,"path":"about/index.html","permalink":"http://thinkhard.tech/about/index.html","excerpt":"","text":"介绍 大家好，我是神奇的战士，一个业余程序员，目前在深圳创业中，写代码和分享代码是\b我的生活乐趣之一。 时间 地点 \b职责 2012 - 2016 哈尔滨工业大学 本科 2016 - 2018 哈尔滨工业大学 硕士 2018 - 至今 哈尔滨工业大学 博士在读 2015 - 至今 乐聚(深圳)机器人技术有限公司 技术总监&amp;合伙人 常用工具 语言：Python、JavaScript、C/C++、Matlab 工具：Emacs、Pycharm、MacOS、Linux、Git、Docker 我的开源项目 wechat_jump_game Douyin-Bot cerebro-codelf 一些书单 《黑客与画家》 《明朝那些事儿》 《用系统来工作》 《搞定 GTD》 《Python3 程序开发指南》 《Reinforce Learning》 《Eloquent JavaScript》 《算法导论》 《人月神话》 联系方式 欢迎一起交流，迸发不一样的火花。 知乎 Github 邮箱：rocksong.hit@gmail.com 微信公众号【神奇的战士】：thinkhardtech"},{"title":"分类","date":"2017-11-08T14:11:32.000Z","updated":"2019-04-04T10:10:23.777Z","comments":true,"path":"categories/index.html","permalink":"http://thinkhard.tech/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-11-08T14:19:19.000Z","updated":"2019-04-04T10:10:23.777Z","comments":true,"path":"custom/index.html","permalink":"http://thinkhard.tech/custom/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-11-08T14:11:50.000Z","updated":"2019-04-04T10:10:23.778Z","comments":true,"path":"tags/index.html","permalink":"http://thinkhard.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dynamicland, 可视空间和设计工坊","slug":"on-dynamicland","date":"2019-06-13T06:51:57.000Z","updated":"2019-06-13T06:59:47.481Z","comments":true,"path":"2019/06/13/on-dynamicland/","link":"","permalink":"http://thinkhard.tech/2019/06/13/on-dynamicland/","excerpt":"","text":"Dynamicland, 可视空间和设计工坊 Vitorio Miliano 从 2017 年 9 月 11 日星期一开始 Dynamicland 发布的一系列照片和视频剪辑让我意识到，我可能错过了一个有意思的东西 -- 并且是最佳实践 -- 那就是 Bret Victor 在 2014 年分享的 “可视空间” 下面是一些我尝试总结的片段。（如果你已经熟悉 Dynamicland，这将会有所帮助） 一个共享的知识空间 在 2013 年，Bret Victor 在《关于道格拉斯·恩格尔巴特的一些话》中批评了那些忽略格拉斯·恩格尔巴特《所有演示之母》真正意图的回顾。 从当今计算机系统的角度来看 1968 年的演示，容易忽略恩格尔巴特对 NSL(oN-Line System) 的定位，即从计算机程序员身上开始，作为增强人类智慧的工具。 最佳的可视化工具是房间 在 2014 年，Bret Victor 发表了《可视空间》，以对话和漫画的形式阐述了“可视空间”的创意，它就像一个工坊或者创客空间，目的是为了帮助人理解而不是建造。 视频中的对话和漫画的结尾都描述了一个未来实验室样子，在这个实验室中到处都是巨大的显示屏，摄像头和分析仪器，帮助创造者们理解他们正在制作的机器人。 文字描述已经过时 也是在 2014 年，Bret Victor 发表了 《 文字描述已经过时: 通过动态模型阐释和理解》，汇总了一系列包括他自己和别人的例子，这其中包括可探索性解释、可交互文档和软件工具，使系统更加直观和易于理解。 关于工具 Bret Victor 在 2014 年有一个的谈话分享，我从中理解到：他说到的是工具，当我们都认真地制造出最符合这种工作方式的工具时，一场革命就将到来。 在我上一个主要的个人项目中，我就是这样做的：我首先开发出工具，让我首先可以全面、深入地理解所做的工作。 Dynamicland 几年之后，我的推特时间线被 Dynamicland 的参与者搞得有些混乱。我花了一分钟才明白我所看到的 Dynamicland，但如果你点击这条推特，就可以很好地理解 Dynamicland： 这个项目起源于 Bret Victor 所在的 Y Combinator HARC 实验室。Dynamicland 是一个允许通过实体对象和交互方式编程的工坊，整个房间就是程序员的 IDE。 但是有另一条推特说道 我在这里引用一下这段话： “把程序从屏幕里搬出来放到桌子上帮助我们互相之间学习”。 那就不仅仅是把房间作为编程的工具。 房间还是一个促进互相之间相互理解的编程工具。 我认为我错过了一些东西。 设计工坊和参与式设计 在 2011 年，Will Evans 发表了一系列的文章，介绍了一个最初源于建筑领域的协作设计、工业设计、无关艺术评论的设计工坊。 设计工坊方法简介 设计工坊的设计 设计工坊和敏捷用户体验：过程和陷阱 自 2011 年 5 月 2 日以来，Will Evans 发布的相簿 在像如产品发掘的过程中，设计工作室方法用于促进参与式设计。 在工坊的整个过程中，所有的参与者都在同一个实体空间中工作，他们使用相同的工具，彼此之间共享知识。使用的工具是标记纸和便笺，目的是为了促进彼此之间的理解。 也许不是工具的问题 道格拉斯·恩格尔巴特希望增强人类的智慧。他的论文《增强人类智慧：概念与框架》没有探究通过其他人来增强智力，而是将 NSL 作为工具来增强，因为它支持广泛的协作。NSL 的参与者可以在相同的 虚拟 空间内同时工作，使用相同的工具和共享知识。 文字描述已经过时是针对工具而言的，但是正如 Bret Victor 在《关于道格拉斯·恩格尔巴特的一些话》 中批判到，这是“当今计算机是针对单用户设计”的产物。在现有的条件约束下，这些是 Bret Victor 能展示给我们的唯一东西。 也许是为了促进共同理解 自从 2010 年以来，我一直在运营着设计工坊，我把上面这张图片和这个引述放到了一起。 “把程序从屏幕里搬出来放到桌子上帮助我们互相学习”。 如果可视空间不仅仅是让一个人看到内部构造，看到时间，看到各种可能性的工具呢？ 如果可视空间应该是让每一个人看到这些事物呢？如果你的所有同事，你的所有朋友，你所有相关人员，都处于同一个空间内，能够看到所有的数据和工具，获取共同的感悟呢？ 这不是一个一群人在里面大房间吗？ 如果我们可以看到未来的可视空间，一个小机器人和一两个创作者在一起，想象未来的工作坊是挤满了相关人员，或者全是学生，所有人都希望去理解、评价和贡献，或许你有一个理论来解释工坊的方法和参与式设计是如何扩展到工作的各个方面的。 设计工坊已经是一个用于描绘和迭代的可视空间：当你呈现和谈论设计时你可以看到内部；你可以看到随着时间的推移每个迭代都建立在前一个迭代之上；你可以看到各种不同的可能性； 如果可视空间仅仅只是一个工具的话，那么我们只能在原地等待这个世界提供这样的工具。 但是如果可视空间包含了其他人或者引导性的话，那么我们我们不仅可以从工作空间中实施流程和开发项目，还可以用仪器探索它，把它们从显示器和服务器中拿出来放到桌子上变成有形的艺术品，我们还能够让人们参与进来。 一个可视空间也可以是非技术层面的，就像一个设计工作室，只要它有 3 种可视化属性。采访和汇报可以可视化内部。可记录和重播的语音和图像、记笔记和分析用来可视化时间。场景规划用来可视化概率。 可视空间也可以是技术层面的。我们可以用投影仪和笔记本电脑拼凑出针对个别问题的解决方案，就像 Dynamicland 一样创造编程的共享感知。 Dynamicland 的哪些方面关于编程的，哪些方面是可归纳的具有普适性的？ 从学习将东西从竖直的屏幕转到水平面（共享的工作台）是否已经足够？ 是否满足前面 3 种可视化的属性，或者是否存在其它的核心属性来促进共享感知？ 在你个人的工作中，从何开始做起？ 现在是 2017 年 9 月 12 日。感谢您的关注。 后续 更新于 2017 年 10 月 1 日 感谢所有的评论和转发。 同样感谢 Atlantic 文章 《即将到来的软件天启日》中的引用： 但看到他的谈话最终产生的效果，Bret Victor 大失所望。他后来说道“很多人似乎误解了我所说的话”。当人们开始邀请他参加会议讨论编程工具时，他就知道人们误会了他的意思。他说道“每个人都认为我对编程环境感兴趣”。事实上他真正感兴趣的事让人们如何看见和理解系统，正如他提到“动态行为的视觉表示”。 至少我并不孤单！","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://thinkhard.tech/tags/Blog/"},{"name":"Translation","slug":"Translation","permalink":"http://thinkhard.tech/tags/Translation/"}]},{"title":"基于 face_recognition 和 PID 的人脸识别和跟踪","slug":"camera-pan-tlt-pid-face-tracking","date":"2019-06-03T07:42:59.000Z","updated":"2019-06-03T10:28:22.457Z","comments":true,"path":"2019/06/03/camera-pan-tlt-pid-face-tracking/","link":"","permalink":"http://thinkhard.tech/2019/06/03/camera-pan-tlt-pid-face-tracking/","excerpt":"","text":"基于 face_recognition 和 PID 的舵机云台人脸识别和跟踪 如何让机器人头部摄像头跟随识别到人脸位置变化而转动？一帧图像是 2 维的，人脸位置用坐标 (x,y) 表示，要实现跟踪人脸则需要两个轴 pan, tilt pan: 水平左右方向转头 tilt: 竖直上下方向转头 人脸识别 首先需要在每一帧图像中识别到人脸，face_recognition 一个简单易用的人脸识别开源项目，并且配备了完整的开发文档和示例代码，还特别兼容了树莓派。face_recognition 基于 C++ 开源库 dlib 的深度学习模型，使用 Labeled Faces in the Wild 人脸数据集进行测试，有高达99.38%的准确率。 安装 face_recognition 安装步骤请参考: face_recognition#installation 识别人脸 Python 代码 12345678910import face_recognitiondef face_location(frame, frame_center): face_locations = face_recognition.face_locations(frame) if len(face_locations) &gt; 0: y0, x0, y1, x1 = face_locations[0] face_x = int((x0 + x1) / 2) face_y = int((y0 + y1) / 2) return face_x, face_y return frame_center PID 控制 使用 face_recognition 可以很容易地用 Python 代码实现人脸识别，计算出人脸在一帧图像中的像素坐标 (x, y)，接下来就是需要控制舵机对人脸进行跟踪。 控制目标：调整横向和纵向两个自由度的舵机，使得摄像头中的人脸中心与图像的中心重合。 这就需要引入 PID 控制了，先直接放公式 \\[ u(t)=K_{\\mathrm{p}} e(t)+K_{\\mathrm{i}} \\int_{0}^{t} e\\left(t^{\\prime}\\right) d t^{\\prime}+K_{\\mathrm{d}} \\frac{d e(t)}{d t} \\] 时间 \\(t\\)，在这里时间是离散的； 偏差 \\(e(t)\\)，在人脸跟踪中指的是图像中心与人脸中心之间的距离（x 方向，y 方向）； 系统输出 \\(u(t)\\)，即输出的舵机角度(分水平和垂直方向两个舵机的角度)； 接下来需要理解，\\(K_p\\)，\\(K_i\\)，\\(K_d\\) 三个参数的作用 比例(P) 比例控制的输出信号与输入偏差成比例关系。偏差一旦产生，控制器立即产生控制作用以减小偏差，是最基本的控制规律。当仅有比例控制时系统输出存在稳态误差。 当人脸与图像中心相距较远时，需要舵机大幅度运动对准人脸 当人脸与图像中心相距较近时，需要舵机小幅度靠近对准人脸 根据 kp 取值不同，摄像头都会去对准人脸，只是 kp 大了到达的快，kp 小了到达的慢一些。 积分(I) 防止系统进入稳定后存在的稳定误差，即有可能摄像头稳定后停下来了，但是没有对准人脸的中心。为了消除稳态误差，必须引入积分控制。积分作用是对历史的偏差进行积分，随着时间的增加，积分输出会增大，使稳态误差进一步减小，直到偏差为零，才不再继续增加，最后系统稳定下来，才可能正好中心对准人脸。 微分(D) 在微分控制中，控制器的输出与输入偏差信号的微分(即偏差的变化率)成正比关系。微分控制反映偏差的变化率，只有当偏差随时间变化时，微分控制才会对系统起作用，而对无变化或缓慢变化的对象不起作用。通俗来说，是为了在人脸追踪时，防止追过劲了，在中心对准人脸后可以及时地停止，防止震荡。 PID 代码实现 在理解概念和公式后，就不难代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# https://www.pyimagesearch.com/2019/04/01/pan-tilt-face-tracking-with-a-raspberry-pi-and-opencv/import timeclass PID: def __init__(self, kP=1, kI=0, kD=0): # initialize gains self.kP = kP self.kI = kI self.kD = kD def initialize(self): # intialize the current and previous time self.currTime = time.time() self.prevTime = self.currTime # initialize the previous error self.prevError = 0 # initialize the term result variables self.cP = 0 self.cI = 0 self.cD = 0 def update(self, error, sleep=0.2): # pause for a bit time.sleep(sleep) # grab the current time and calculate delta time self.currTime = time.time() deltaTime = self.currTime - self.prevTime # delta error deltaError = error - self.prevError # proportional term self.cP = error # integral term self.cI += error * deltaTime # derivative term and prevent divide by zero self.cD = (deltaError / deltaTime) if deltaTime &gt; 0 else 0 # save previous time and error for the next update self.prevTime = self.currTime self.prevError = error # sum the terms and return return sum([ self.kP * self.cP, self.kI * self.cI, self.kD * self.cD]) 代码设计 由于云台有 2 个自由度（pan, tilt），所以需要用到 2 个 PID 控制器，来输出对应的角度 \\(x\\) 轴偏差 对应 水平左右转动 pan \\(y\\) 轴偏差 对应 垂直上下转动 tilt 在代码设计时，需要考虑如下几点限制因素 受限于设备的性能，使用 face_recognition 识别一帧图像里的人脸可能会非常耗时 舵机控制时，不同的舵机响应时间不同 PID 在代码中是通过循环累加来计算的； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def thread_face_center(): print('face_center ..') process_this_frame = 0 while True: time.sleep(0.01) if not QUEUE_IMG.empty(): frame = QUEUE_IMG.get() else: continue (h, w) = frame.shape[:2] HEAD.center_x = w // 2 HEAD.center_y = h // 2 if process_this_frame &gt; 8: HEAD.obj_x, HEAD.obj_y = face_location(frame, (HEAD.center_x, HEAD.center_y)) print(HEAD.obj_x, HEAD.obj_y) process_this_frame = 0 process_this_frame += 1def thread_pid_pan(): p, i, d = 0.09, 0.08, 0.002 pid = PID(p, i, d) pid.initialize() while True: error = HEAD.center_x - HEAD.obj_x HEAD.pan = pid.update(error)def thread_pid_tlt(): p, i, d = 0.11, 0.10, 0.002 pid = PID(p, i, d) pid.initialize() while True: error = HEAD.center_y - HEAD.obj_y HEAD.tlt = pid.update(error)def thread_set_servos(): set_head_servo([0, 90]) while True: time.sleep(0.01) pan_angle = HEAD.pan + 0 tlt_angle = 90 - HEAD.tlt print('[pan_angle, tlt_angle] = ', pan_angle, tlt_angle) set_head_servo([pan_angle, tlt_angle]) 需要将人脸识别、PID 过程、角度控制放到单独的线程处理。 1234async_do_job(thread_face_center)async_do_job(thread_pid_pan)async_do_job(thread_pid_tlt)async_do_job(thread_set_servos) 参考链接 Wikipedia: PID 控制器 The world's simplest facial recognition api for Python and the command line Pan/tilt face tracking with a Raspberry Pi and OpenCV","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"PID","slug":"PID","permalink":"http://thinkhard.tech/tags/PID/"},{"name":"Robot","slug":"Robot","permalink":"http://thinkhard.tech/tags/Robot/"}]},{"title":"用 Docker 部署 Sentry Bug 日志收集服务","slug":"docker-sentry-deploy","date":"2019-05-25T02:44:27.000Z","updated":"2019-05-25T10:27:24.928Z","comments":true,"path":"2019/05/25/docker-sentry-deploy/","link":"","permalink":"http://thinkhard.tech/2019/05/25/docker-sentry-deploy/","excerpt":"","text":"用 Docker 部署 Sentry Bug 日志收集服务 Sentry 是一个日志收集和统计平台, 由客户端和服务端组成，目前支持大部分主流的编程语言，并提供 SDK，当程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个 Web 端显示。 下面演示如何使用 Docker 快速部署 Sentry 服务，并自定义一些配置。 系统环境 12&gt;&gt; uname -aLinux sentry 4.18.0-1018-azure #18~18.04.1-Ubuntu SMP Tue May 7 18:09:35 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装 Docker 12345&gt;&gt; sudo apt install docker.io&gt;&gt; sudo apt install docker-compose&gt;&gt; docker -vDocker version 18.09.2, build 6247962 部署 Docker 服务 Clone 代码 12&gt;&gt; git clone https://github.com/getsentry/onpremise.git&gt;&gt; cd onpremise 挂载本地路径 为了方便数据迁移，挂载本地路径到 Docker 镜像 mkdir sentry-data: 创建 Sentry 数据文件目录 mkdir sentry-postgres: 创建 Sentry 数据库目录 config.yml: Sentry 用户自定义配置文件 配置邮箱与域名前缀 这里需要同时改动两个文件，config.yml 和 docker-compose.yml 配置 config.yml 12345678mail.backend: 'smtp' # Use dummy if you want to disable email entirelymail.host: 'smtp.exmail.qq.com'mail.port: 587mail.username: 'name@email.com'mail.password: 'yourpassword'mail.use-tls: truemail.from: 'name@email.com'system.url-prefix: 'http://your_domain.com' 配置 docker-compose.yml 1234567891011121314151617181920x-defaults: &amp;defaults restart: unless-stopped build: . depends_on: - redis - postgres - memcached - smtp env_file: .env environment: SENTRY_MEMCACHED_HOST: memcached SENTRY_REDIS_HOST: redis SENTRY_POSTGRES_HOST: postgres SENTRY_SERVER_EMAIL: 'name@email.com' SENTRY_EMAIL_HOST: 'smtp.exmail.qq.com' SENTRY_EMAIL_PORT: 587 SENTRY_EMAIL_USER: 'name@email.com' SENTRY_EMAIL_PASSWORD: 'yourpassword' SENTRY_EMAIL_USE_TLS: 'true' SENTRY_URL_PREFIX: 'http://your_domain.com' 注意 邮箱端口： 腾讯企业邮箱的设置 SMTP 的端口是 465，但 sentry 只支持 tls 而，所以使能 tls 并将端口改587。 腾讯企业邮箱 mail.from 必须要和 mail.username 一致。 启动 Docker 服务 参考官方文档 cp -n .env.example .env 创建环境配置文件 docker-compose build 构建 Docker 服务 docker-compose run --rm web config generate-secret-key 生成密钥，并将密钥添加至 .env docker-compose run --rm web upgrade，构建数据库，过程中需要输入管理员信息 docker-compose up -d 在后台启动，docker-compose.yml 默认端口为 9000 浏览器打开 http://localhost:9000，部署成功。 作者 神奇的战士 微信公众号","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://thinkhard.tech/tags/Docker/"},{"name":"Sentry","slug":"Sentry","permalink":"http://thinkhard.tech/tags/Sentry/"}]},{"title":"在 Scratch3 中玩转机器人:Python、Deep Learning、Posenet and Robot！","slug":"control-robot-in-scratch3","date":"2019-05-23T13:21:12.000Z","updated":"2019-05-24T09:31:28.525Z","comments":true,"path":"2019/05/23/control-robot-in-scratch3/","link":"","permalink":"http://thinkhard.tech/2019/05/23/control-robot-in-scratch3/","excerpt":"","text":"在 Scratch 中玩转机器人：Python、Deep Learning、Posenet and Robot！ 所有的边界都被打破了 --《Mindstorms》第二版序言 开场视频：先打个响指 打响指控制机器人 Codelab-Scratch3 与 Python Scratch 是一门编程语言，上榜过编程语言 Top 20，实际它是一门少儿编程语言(如果你成年了请先不要急着走)。Scratch 基于图形化的编程，通过拖拉搭积木的方式进行编程，整个过程就像是在玩乐高积木，其实 Scratch 项目受到乐高的赞助，乐高与 Scratch 之间可以说是互相影响。 一个正经的程序员，在看到 Scratch 的卡通界面和图形化编程风格时，可能会嗤之以鼻，认为它看上去不像是严肃的编程语言，低龄化或者太简单了。刚开始我对 Scratch 的认知亦是如此。 [@wwj718](https://github.com/wwj718) 在 Scratch3 上做了大量出色的工作，Scratch3 原本不支持运行 Python，利用 Scratch3 原生的插件拓展机制，采用 Websocket 来传递消息，这就像一个间谍，负责 Scratch 内部与外部的通信。消息源源不断地以话题/订阅的方式在网络中传播，这就让 Scratch 不再受限于浏览器网页中。我终于意识到，Scratch 可以做任何事！ 从上图看出，整个系统可以看做是三个部分： Scratch3：负责 Block 代码生成与运行，通过 websocket 传输消息； Codelab-Adapter：响应 Scratch 消息，Python 插件管理； Python 插件集合：负责连接万物！ 按照这样的设计，Scratch 获得了 Python 的能力，可以将 Python 丰富的生态和库统统接入 Scratch，比如 TensorFlow、ML、DL，甚至可以是树莓派、灯泡、门锁、空调、机器人、游戏 ... Bret Victor 在《Kill Math》中说道 &gt; 理解并预测量化世界的能力不应该只属于那些能够熟练运用抽象数学符号的人。 而现在编程的能力也不应该只掌握在程序员的手上，在 Codelab-Scratch 中，用户可以快速和轻松地使用这些能力。 为了向你证明这一切，下面是我在 Scratch3 中做的一个演示 人体姿态估计：Posenet Javascript 版 PoseNet 是 TensorFlow 与谷歌创意实验室合作一款机器学习模型，可以在浏览器中实时估计人体姿态。只要电脑或手机有摄像头，就可以直接在网页浏览器中体验这一有趣的技术。Scratch3 也是纯网页端的，所以将 PoseNet 做成插件的话，Scratch 积木块就具有视觉的能力！ 针对 PoseNet，@wwj718 已经在 Codelab-Scratch3 中接入了，智能硬件接口开放的话，接入 Scratch 中，就可以让原本功能单一的产品很容易地获得视觉能力。我相信这就是为我今天的演示所准备的，做一个 Scratch 版本的机甲猎人! 如何接入机器人到 Scratch3 首先硬件设备需要有开放的接口，比如开放的蓝牙协议、串口协议或者 Wi-Fi 协议等，Python 有非常成熟的库可以对这些接口进行调用(不开放也没关系，可以 Hack)。 我已提交相关机器人 Adapter 插件，感兴趣的可以参考我的 PR codelab_adapter_extensions/pull/13 codelab_adapter_extensions/pull/14 手势控制演示 手势控制机器人前后左右翻滚 翻跟斗演示视频 姿态模仿演示 下面是姿态模仿演示，请大家忽略我羞耻又沙雕的动作，和不协调的肢体。 姿态模仿演示视频 最后 如果你也对这一块感兴趣，欢迎加入社区一起折腾。 相关链接 Kill-Math Aelos Edu scratch3.codelab codelab-adapter-docs Pose Detection in the Browser codelab_adapter_extensions/pull/13 codelab_adapter_extensions/pull/14 鸣谢 @jinbo 的 OSMO； @yucong 的手抖式拍摄； @jianhong 的专业动作调试； @dongming 的无线 Dongle； @carlos 的响指；","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Scratch3","slug":"Scratch3","permalink":"http://thinkhard.tech/tags/Scratch3/"},{"name":"Posenet","slug":"Posenet","permalink":"http://thinkhard.tech/tags/Posenet/"}]},{"title":"【译】Kill Math(Bret Victor)：让数学不只是符号","slug":"Kill-Math","date":"2019-05-16T12:51:18.000Z","updated":"2019-05-16T13:11:24.587Z","comments":true,"path":"2019/05/16/Kill-Math/","link":"","permalink":"http://thinkhard.tech/2019/05/16/Kill-Math/","excerpt":"","text":"Author: Bret Victor / April 11, 2011 Translator: 神奇的战士 Bret Victor 是苹果公司的前 IPAD 的交互设计师, 大神级的人物。他的理想是：改造我们的低幼化社会。为人们提供工具，用以抵抗和摧毁消费主义文化以及大企业对工作、娱乐和创造力的寡头控制。将权力、尊严和责任感还给个人。Bret 有很多惊艳的作品，感兴趣的同学可以在 Youtube 上搜一下。这篇文章中 Bret 认为大多数人应该用直觉去感知和理解数学符号，而不是靠符号演算。下面是正文： 理解并预测量化世界的能力不应该只属于那些能够熟练运用抽象数学符号的人。 当大多数人谈及数学的时候，脑袋里想的更多是数学的机理而不是思考数学的本质。赋予符号含义、按照神秘的法则的变换和根据变换来解释意义组成了这种所谓的“数学”。整个过程就像是在抓阄一样。 如此的数学机制发展起来是有原因的：这是在纸和笔的限制下构建的最有效的数学系统。但是很遗憾的是，大多数的人们并不习惯将含义和数学抽象符号联系到一起并且很熟练地使用它们。所以除了算术，数学的力量只是掌握在少数的科学家和工程师的手上（虽然嘴上不说，但是他们中的大多数也是饱受抽象符号的煎熬）。 现在我们将不再受限于纸和笔。抽象的符号变换不应该再是理解数学的唯一手段了。数学需要有新的形象。 项目 Kill Math 是一个综合的工程项目，目标是帮助人们通过更具体的表现以及更符合直觉的形式来探索和解决一些有意义的量化问题。长远的目标则是希望能够建立一套不同于现有的符号数学体系的可广泛使用并自动呈现的可视化数学表示方法。 在未来的某一天，在这篇博客内可能会有一篇介绍的文章，让你感动到流泪。但是这篇文章还没写，因为它需要大量的思考和演示示例，在此之前我需要深刻地理解我正在努力做的工作。 下面是我目前已经完成的部分： 通过媒介来思考原本不可思考的 是一系列交互式的用于设计和理解系统的演示，并且整合了下面列出的很多工作。 擦写计算器 演示了在不使用符号变量的情况下解决实际的代数问题。不是求解 x 和 y，而是通过交互的方式调整变量。 动态系统的互动探索 演示了一个控制微分方程的工具，其中的每一个变量都用图表显示，每个参数都有一个旋钮，可以实时地进行调整。这套工具可以帮助用户了解参数是如何影响整个系统行为的。 如何运用抽象是一篇可交互的博客，使用系统可视化来帮助设计和理解一个系统。 将模拟作为一种实用工具 是这篇文章的早期形态，这个项目主要是为了验证想法。 下面是一系列关于这个数学主题的博客漫谈，我希望吸引更多志同道合的人，而不是为了说服那些持怀疑态度的人。(在怀疑论者看到更多的例子之前，他们可能会拒绝被说服。) 我计划在不同的应用领域和数学领域收集一些有意义的问题，按照这里的哲学针对每一个问题，设计出一种解决方案，将此解决方案与传统解决方案进行比较。我希望在这个过程中出现的一些技术和设计模式可以为将来一般性的的框架提供参考。 跟往常一样，如果你在用类似的方式思考和工作，我很想看看你想出了什么有意思的点。 一些附加的想法发表在 Fast Company 杂志的这篇文章里 杂记 语言与内在解释 (1) 理解和预测数是一种相当强大的力量。目前，这种能力掌握在极少数能够熟练运用数学抽象符号的人手中。 相比之下，考虑识字能力。从一个不在同一地点或时间的人那里接收思想的能力同样是一种巨大的力量。识字率上升带来的巨大社会影响也是众所周知的。 语言素养比数学素养更加普及。几乎所有“受过教育”的人都能阅读，大多数人甚至可以在某种程度上写作。但是大多数受过教育的人除了算术之外没有掌握什么有用的数学技能。 写作和数学都是基于符号表示的系统。但我认为语言更加自然，因为语言的符号直接映射到单词或音素上，这是人类与生俱来的能力。我想，阅读和听别人说话或看手语有着相同的心理机制。 我不认为每个人在处理数学符号上有着相同的天赋【注1】。相反，我们倾向于阐释隐含的物理含义，这两种隐喻都适用于使用抽象符号的机制（例如，“移动”一个因子到等式的另一边，“消除”两个因子，等等）和符号的语义解释（例如，指数“上升”，或者公式的可忽略项）。在一定程度上，一个人的数学能力和感受这些物理隐喻的符号紧密相连，从而使抽象的更具体。 【注1】: 西蒙·佩伯特可能不会同意这样的观点，他认为对于在 “Mathland” (一个沉浸式的数学互动环境) 中长大的孩子看来，使用数学就像是在法国说法语一样，可以熟练地使用抽象的数学符号。我可能反驳说，在南极长大的孩子可能会更抗冻，或许人们并不需要这种抗冻能力。 我相信这两种精神上的扭曲都是在纸笔技术下的产物。一个人不应该手动地去变换符号和数学推导。因为这些工作最好完全由软件自动完成，或者像玩滑动拼图游戏一样，有一个可交互的带引导的软件。可能更具争议的是，我认为一个人不必去理解抽象符号的含义。相反地，动态图、图表、可视化模型和视觉特效就可以阐释事物本质。比如数值之间的关系、指数上升和公式的可忽略项应该被直观地用眼睛看到，而不是单纯地靠脑海想象。 语言与内在解释 (2) 人类是为语言而生的 -- 我们是处理符号的机器 -- 所以我不能说“符号的坏话”。我感觉有一些东西需要亲眼所见或者亲身体会才能够真正的理解与融会贯通。并且一些东西是可以很容易地绘制或者制作，对于那些缺少使用晦涩难懂的专业语言的经验的人来说，这很难用符号表述。 我认为数量和度量就属于这个范畴。例如长度 1m 和 1mm 的符号表示与直接观察这两种长度相比 -- 前者只是一页纸上的数字，而后者可以让你直观地感受。你觉得大多数人能够从符号上，感受和理解 $1B 和 $1T 财政救助款之间的区别吗？事实上它俩之间差了整整 3 个数量级。 你需要使用本能的直觉去理解一个问题。一个优秀的电路设计师能够感知到一个电路是如何运作的。当他们看着电路原理图的时候，就能感受到电压的脉动，就好像看着跷跷板或者水泵运作一般。然而这需要多年的经验来形成这种当你看着符号的时候就能理解符号含义的直觉。 同样地，人们以前认为去阅读和理解巨大的数字表格是处理数据的基本技能。但是威廉·普莱费尔发明了线形图，突然间所有人都可以通过平凡的眼睛来直观地感受数据。 复数提供了一个很好的例子。在许多科学领域，理解抽象的复数是一项基本技能。然后 David Hestenes 站出来说：“嘿，你知道复数、四元数、泡利矩阵和其他抽象有趣的东西吗？如果你用过克利福德代数的话，所有的这些东西都有几何表示，并且你可以实际地体会和品味到它们。”用你愚笨的嘴去品味复数！事实上没有人相信他，但是我相信。 我们的工具的目的就是使那些无法企及的抽象事物让普通人也能理解，将它们转换成我们能够感受到的形态。显微镜能够让我们的眼睛看到微小的事物。镊子能够让我们笨拙的手指夹起细微的颗粒。计算器能够让我们愚笨的大脑完成复杂的计算。所以我想有那么一个工具可以让我们普通的大脑看见和体会复杂的情景。 厨房里的数学 在 《儿童的机器》 这本书中，西蒙·佩伯特介绍了“厨房里的数学”。一道菜需要给 3 个人吃，但是厨师只做了 2 份菜，所以她需要将原材料的均分 2/3。一道菜需要 3/4 杯面粉。厨师量出 3/4 杯面粉，在柜台上摊开成一个圈，从圈里拿出1/3块，放回袋子里。这就是 2/3 和 3/4。 有些人显得很慌张因为他不会使用分数，但是我发现了一个有趣的解决方案。因为分数是具体的、可见的、有形的和直接的。传统的方法就是分子分母上下同时约掉 3，但是这没有任何的物理意义。 我想要创造出一个环境来增强厨房里的数学。 数学的艺术 这个项目没有处于自身观点考虑来攻击应用数学。我不介意数学娱乐化或者艺术化。我一直出于个人兴趣在学习数学；我始终在以数学为乐。我对洛克哈特的悲歌产生了强烈的共鸣，并且我很喜欢 Vi Hart 和 Mike Keith 等人所做的工作。在模式和规则中隐藏着美感；但是发现这种美是有挑战的。我可能会因为盲目的传统和缺乏想象力的原因，迫使我使用古老的传统方式来完成这样的艺术形式。 以武术为例，这是另一种根据实际需要而发展出来的艺术形式。就像数学一样，人们练习武术可能是以为了身体或精神上的锻炼，为了挑战和掌握一项技能，为了它的优雅和美丽，或者作为一种社交活动为目的。与数学不同的是，我们意识到武术的精神已经发生了改变，因为随着技术的进步产生了更多教训人的方式。 （与数学不同的是，我们不会强迫地球上的每一个孩子上 12 年的课，那些在艺术方面不擅长的孩子也不会感到羞耻和低人一等。） 可能令人尴尬的个人往事 当我读高中的时候，我每周会去几次当地的大学学习微分方程。有一天，老师解完一个二阶方程式： 他很随意地提出了一个问题：“你为什么认为这个解有两个任意常数？” 对这个问题我感到很疑惑，我认为答案本该如此呀。我能看出解有两个自由度，我能理解到这个程度，但是我从来没想到还有更深层次的原因。 老师然后说道，“因为你积分了两次”。然后他就开始继续讲其他的东西了，但是我小脑袋里已经满满都是问号。 我从来没有想过通过积分来求解微分方程。因为它看起来并不像积分。我知道积分是什么样的 -- 积分就是把东西都累加起来，就像往水槽里加水一样。 并且我知道方程直观感受起来是什么样的 -- 它就像天平，慢慢地摆动越来越小，最后停了下来。 后来我上了大学，从学校毕业后，开始了工程师的职业生涯，我没有被要求解上百上千个的微分方程。我理解了微分和积分在形式上的关联，但是我不知道我是否可以直觉感受到它。 后来有一天，我无意中读到斯托加茨的书 《Nonlinear Dynamics and Chaos》。在书中他问道，如何求解下列的微分方程： 随后他说，你不要这么做。它是非线性的。我们单单变换公式的方法不管用了。你需要把二阶的方程分解成两个一阶微分的方程式。 画出相位空间的轨迹图，然后你就能直观地感受到整个系统的运作方式。 在轨迹的每一点上，鼠标在水平和垂直方向都被微分推进了一点点，整合起来就像 LOGO 语言的小海龟在相位空间运动一样。 为什么我整个职业生涯都在整合一个我们看不见的东西呢？对我而言，如果不在相位空间理解微分方程就像是没听过一首歌却要做音乐鉴赏一样。 回想多年前我的老师提出来的问题：“为什么解是两个任意常数？”答案就很显然了：你必须选择轨迹得起始点，两个常量就像是小海龟做积分时的坐标 x 和 y 一样。我很多年以前就解决了“初值问题”，我却从来没有切身体会过这个初值。 教育和命令行 当这些笔记第一次发表的时候，我收到了很多读者的反馈。但是大多数的反馈都是以为为我想要变革 数学教育。有一个部分我简短切题地说道这个项目不是关于教育的，其他地方我没有提到过教育。 我发现这很令人费解。如果我提出一种新的驾驶汽车的方式（比如，我说方向盘这东西已经过时了，应该被替换为 Wii 游戏手柄），应该不会有人认为这是谈论 汽车司机教育 吧。甚至没有人会提到教育二字。他们可能会思考这是否是一种开车的好方法。 但是当说道一种新的理解数学的方式时，人们总是开始联想到教室和课程。 有一点尤其奇怪，当今解决实际生活中的数学问题总好的工具竟然是是电子表格。如果我需要一个新的形式的电子表格，同样，没有人会说这是关于教育的。 （这种对教育领域的重新定位也发生在对一个动态系统的交互探索的演示中。肯定我本可以做得更好的：“这是一个原型工具，工程师和科学家可以对他们正在进行工程和科学系统进行建模和探索”。但是我认为这更加贴切这个工具的本意而不是仅仅“可视化 Lotka-Volterra 方程”。大多数的读者都想要像 Wolfram 那样的演示，对某个具体的数学问题进行可视化。这种感觉就像，我展示了一个全新的漂亮的不粘锅，后来每个人都上来问我要一盘美味的炒蛋。） 如果让我猜测为什么“数学改革”被误解为“数学教育改革”？我推断大多数人可能只在学校里和数学打交道。就像校园物理或者校园化学一样，数学被视为一门课来教授，而不是强调它是一种工具。人们在算术之外并没有在实际生活中使用数学，就好像不使用平方反比定律或者周期表一样。 这就是这个项目出发的前提 -- 大多数人们没有使用数学。但是如果数学被以一种更好的方式教学的话，人们可能会把数学用得更好！我（包括整个项目）的立场是：不。教学目前你想要的数学抽象符号和方法 -- 他们将仍然没有作用。使用糟糕的用户界面的教学方式仍然是没有用 -- 因为没有展示出用户需要看到的东西，不符合用户大脑里所想的内容，没有呈现出用户可以采取的操作。 对于大多数人来说 UNIX 命令行仍然是没有用的。有很多方法可以让普通大众使用计算机的强大之处，而不必教会每个人都去使用命令行。有一个很好的方法就是 -- 设计更好的用户界面，更多易访问的应用程序，更高级的抽象。直接形象地和真实地表现事物。 所以当今的数学就像是命令行，我们需要更好的用户界面。 别人说过的观点 奥利弗·斯蒂尔: 邮件 所有的不具体的抽象事物都是很难去想象的...我认为数学家是那些可以成功地弄清楚如何具体地思考抽象事物的人，所以抽象就不再抽象。我相信数学思维包括学习具体地思考抽象事物的能力，通常使用多种表示法 -- 如何将更多的事情视为“事情”的一部分。所以与其说避免抽象，更重要的是接纳抽象并且将抽象具体化...具体化抽象事物的一种方法是在旁边放一个已经具体化的实例。 大卫·赫斯顿斯和盖瑞特·索布奇克: 《克利福德代数到几何微积分：统一的数学语言》 克莱恩对数学结构和历史的开创性研究揭示了数学发展和分支的两个主要过程...一种强调代数结构，另一种强调几何解释。克莱恩的分析表明，在数学的历史发展过程中，一个过程交替地支配着另一个过程。但这两个过程不应相互排斥。毫无疑问事实上每一个过程都是建立在人类思维的两大能力之一上的：语言能力和空间感知能力。从心理学的角度来看，代数与几何的融合是非常基本的所以我们可以说：没有代数的几何是愚蠢的！没有几何的代数是盲目的！， 大卫·赫斯顿斯: 《改变物理的数学语言》 在物理课程中，数学被认为是理所当然的 -- 这是一成不变的真理。数学对我们的物理世界的深刻影响却从未被认真分析过。今天使用的数学工具是在过去被发明出来解决旧的问题，但是很有可能不太适合今天新的问题... 我们不必深入研究物理学的历史来证明数学对物理的深远影响。因为有两个著名的例子足以说明这一点：解析几何和微积分的发明是牛顿创立经典力学的基础，张量分析的发明对爱因斯坦创立广义相对论至关重要... 我想通过引用这两个例子来说明的一点是，如果没有基本的数学概念，这两个物理理论实际上是不可想象的。我们使用的数学建模工具曾经扩展但也限制了我们认知世界的能力。数学的局限性在于，那些为经典力学和解析几何学提供的数学支撑的理论方法已经不适用于广义的相对理论了。当今在物理学使用的数学工具可能在概念上就存在局限性。 艾伦·凯：《用图像制造符号》 法国著名数学家雅克·阿达玛在他晚年时决定投票选出他的 99 个同伴，作为地球上 100 位最伟大的数学家和物理学家，雅克问他们：“你们的工作怎么样？”。他们都是私交，所以纷纷回信。只有一百人中的几个人声称他们使用数学符号。这着实令人惊讶。他们中的大多数人以意象或比喻的方式来理解数学。有 30% 的人包括爱因斯坦都是这样。爱因斯坦说道，“我对数学有肢体一般的感受。”爱因斯坦就像感知自己的手臂和手指一样去感受抽象的空间。 [做某事 &gt; 图像 &gt; 符号]中令人难过的部分就是，美国的所有孩子都在以符号的方式去学习数学和物理。但没有一个有创造性的数学家或者物理学家在以这种方式学习...他们使用符号的方式交流，但是实际研究的时候就不是这样。太多的教育是建立在这种规则之上了，仅仅是因为我们以谈话的方式来交流，但是这并不意味着只靠说和听去教学。 威廉·瑟斯顿：《论数学的证明和发展》 当有一个重要的理论被证明的时候，通常该解法可以很快地在相关子领域内传播。这个证明如果是通过沟通交流的话可以在一小时之内就被该子领域的其他研究人员理解。但是如果写成 15 或 20 多页的论文，人们可能需要好几个小时甚至好几天才能够理解掌握。 为什么非正式的讨论和直接磕论文之间有这么大的区别呢？当一对一沟通的时候，人们除了数学语言还可以用很多其他的方式来交流。他们可以用手势、画图表、用肢体语言发出声响这些方式交流。沟通在这里就是双向的，人们可以专注于他们最关心的点上。以面对面的沟通方式，就可以更好地传达正在发生的事情，不仅在逻辑和语言方面，而且在其他心理层面。 在会谈中，人们变得更加拘谨和正式。数学的受众通常不善于提出大多数心中所关注的问题，而演讲汇报的人通常准备了一个不切实际的大纲，即使他们被问到问题，也会回避相关的回答。 在论文中，人们会仍然会比较正式。写作者将他们的想法翻译成符号和逻辑表达，读者努力地要将它们翻译回来。 理查德·汉明：《数学的不合理有效性》 有必要强调一点，数学的前提假设不是摩西从西奈山上取下来的石板。一开始我们头脑中有了一个模糊的概念，然后我们各种各样的假设集合，最终慢慢地收敛成一个特定的集合。在严格的假设方法中，原始模糊的的概念会被后来假设所定义的内容代替。这就使得很难有概念上的发展，进而减缓了数学的发展。并不是说假设的方法是错误的，只是应该清楚认识到它的任意性，注意当结论慢慢变得清晰时我们应该准备改变假设。 理查德·汉明：《科学与工程的艺术》 当数字滤波器首次出现时，它们仅仅被视为经典模拟滤波器的一个变种；人们不认为它本质上有什么新意或者不同。这就和早期人们对计算机的认知错误一样。多次有人跟我说，计算机只是一个大型的计算的台式计算器，后来我都厌倦了这种说法。他们说，“任何机器能做的事，人工也能办到”。但是这种观点的人忽视了机器与人工相比，在速度、精度、可靠性和低成本上具有巨大的优势。一般来说，一个数量级的变化（10 倍）将会产生本质上的影响，更不用说计算机比人工计算快了许多许多倍了。那些声称没有本质区别的人从未对计算机的发展做出过任何重大贡献... 这是一个常见的、无休止的错误；人们总是想认为新事物就要像过去的东西一样 -- 他们习惯于处在大脑的舒适圈 -- 因此他们抗拒对眼下正在发生的新领域新事物做出任何大的贡献。 史蒂文·斯托加茨: 《非线性动力学与混沌理论》 感谢你能够看到这里，我们在此相遇。这篇文章是我在 codelab-mindstorms 项目里提交的一篇译文。如 @wwj718 提到的，在编程教育领域有很多“编程提高逻辑思维的”陈词滥调，其实这个在这个领域有一群杰出的先驱做了大量的工作，但是这些却渐渐被世人遗忘。 如果你也感兴趣的话欢迎一起来 Github 社区翻译和解读编程教育领域优秀的先驱所做的工作。在这个过程中如果你不会操作 Github 或者提交代码，请让我来帮助你 rocksong.hit@gmail.com 。 项目地址: Scratch3Lab/codelab-mindstorms","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://thinkhard.tech/tags/Blog/"},{"name":"Translation","slug":"Translation","permalink":"http://thinkhard.tech/tags/Translation/"},{"name":"Math","slug":"Math","permalink":"http://thinkhard.tech/tags/Math/"}]},{"title":"当遇到 Scratch3-Codelab，Pando 觉醒了！","slug":"codelab-pando-tutorial","date":"2019-04-17T07:17:02.000Z","updated":"2019-04-17T13:42:59.328Z","comments":true,"path":"2019/04/17/codelab-pando-tutorial/","link":"","permalink":"http://thinkhard.tech/2019/04/17/codelab-pando-tutorial/","excerpt":"","text":"当遇到 Scratch3-Codelab，Pando 觉醒了！ Explore Amazing Moment With Pando Pando 是由乐聚机器人研发，可以进行情感互动的益智编程机器人。主要功能包括情感交互、手势控制、自主避障、积木编程、动作编程、任务挑战、拟人步态等功能。 图片来源：lejurobot.com Scratch3-Codelab Scratch3-Codelab 是 wwj718 在 Scratch3 的基础上，集成 EIM (Everything is Message)插件，配合 codelab_adapter，就可以让 Scratch3 可以执行 Python 代码，这就赋予了 Scratch3 几乎无限的可能性。 系统框图 如果可以运行 Python 代码，那么理论上就能把任何智能硬件都接入 Scratch3 当中，而且模块和插件越多，Scratch3 的玩法就越千变万化！ 图片来源: techziffy.com 作为一个少儿编程产品，孩子们的想象力其实是远远超过成年的工程师的，如果做到尽可能的开放，让他们去创造和探索机器人的功能，这将是一件非常有意思的事情。 非常有幸邀请文杰来公司一起交流畅谈，被 CodeLab 万物积木化 的想法深深吸引，第二天花了一些时间，参照 Codelab-adapter 文档，为 Pando 写了 Codelab 插件 Pando Robot Extension ，成功接入 Pando 到 Scratch3 当中。下面是系统框图： 视频演示 YouTube: 在 Codelab 中控制 Pando 机器人 By 神奇的战士 Bilibili: 在 Codelab 中控制 Pando 机器人 By 神奇的战士 软件使用 MacOS/Linux 安装 codelab-adapter 和使用说明 插件安装 Pando 插件 extension_leju_pando.py 蓝牙服务端 pando_server.py pip3 install pyzmq --user 安装 Adafruit_Python_BluefruitLE 按键控制 Pando 微信遥控 Pando 语音控制 Pando 更多玩法 将 Pando 的运动功能封装成 Block，在 Codelab 平台上就能赋予其更多的 AI 能力，例如 人脸识别和手势识别控制 Pando 与 Pando 聊天对话 Pando 与任何智能硬件交互 更多有趣的玩法请参考演示视频 我们相信，孩子的想象力是天马星空的，如果把学习一门编程语言的门槛抹平，他们将能创造出更多令人惊叹的作品。 参考链接 Codelab Vector 插件 Welcome to codelab-adapter Adafruit_Python_BluefruitLE 关于作者 神奇的战士 公众号【神奇的战士】 来自乐聚的一个工程师 Github: wangshub 邮箱：rocksong.hit@gmail.com","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Scratch3","slug":"Scratch3","permalink":"http://thinkhard.tech/tags/Scratch3/"},{"name":"Codelab","slug":"Codelab","permalink":"http://thinkhard.tech/tags/Codelab/"}]},{"title":"推荐一个 MacOS 上用了就无法自拔的神器 [Hammerspoon] 和我的配置方案","slug":"hammerspoon-introduce","date":"2019-04-08T14:26:58.000Z","updated":"2019-04-09T06:12:15.889Z","comments":true,"path":"2019/04/08/hammerspoon-introduce/","link":"","permalink":"http://thinkhard.tech/2019/04/08/hammerspoon-introduce/","excerpt":"","text":"推荐一个 MacOS 上用了就无法自拔的 App Hammerspoon！ Hammerspoon 是 MacOS 上的自动化工具，许多介绍 Hammerspoon 的文章都主要介绍了它是一个窗口管理工具，但是 Hammerspoon 能做到的远远不仅如此。 Hammerspoon 开源、免费和支持插件，将大多数系统层面的接口封装成了 Lua API，这就让这把小锤子在 MacOS 上近乎无所不能，可玩性极高。 我都用 Hammerspoon 做了些什么？ 菜单栏显示最近几天天气情况 参考示例 请求免费的天气 API，在深圳这个多雨的城市里提醒我别忘记带伞。 剪切板历史记录 参考示例 记录剪贴板历史，点击某一项再重新复制。 音量调节快捷键 参考示例 当我使用外接键盘时，自定义快捷键 cmd + up/down 调节系统音量 窗口管理 参考示例 快捷键实现二分屏、三分屏和全屏 Wi-Fi 自动脚本 参考示例 根据 Wi-Fi SSID 判断是否在公司还是在家，例如在家里自动挂载 NAS 服务器，如果在公司 sshfs 挂载服务器目录等。 蓝牙耳机自动连接 参考示例 电脑锁屏时，自动断开连接的蓝牙耳机，参考我的另一篇介绍。 输入法自动切换 参考示例 在每个 App 界面自动切换成搜狗输入法，配合搜狗输入法自动中英文切换，再也不用在系统默认的英文输入法和搜狗输入法之间来回切换了。 定时自动提交代码 参考示例 使用 hs.timer 定时器，定时自动推送我的笔记和下载的电子书到 Github 仓库。 USB 设备连接记录 参考示例 记录插上你电脑的每一个 USB 设备信息，凡插过必留记录。 消息推送 参考示例 推送任意消息提醒 TTS 发声 参考示例 调用 say hello world 合成 TTS，模拟真人发音，让 Mac 会说话。 更多... (完全停不下来啊) 其他插件思路 番茄钟 应用搜索 桌面小部件 ... 使用入门 Hammerspoon 已经将与 MacOS 之间的系统交互封装成了 Lua 的 API，配置 ~/.hammerspoon/init.lua 脚本可以与系统进行交互，只需要了解一些基本的 Lua 语法，就可以 Happy Hacking 了 Lua 快速入门教程 Hammerspoon API 文档 我的参考配置 如果你懒得配置，可以参考我的配置，根据自身需求修改 wangshub/hammerspoon-config 最后 已经完全停不下来了，Hammerspoon 每天至少省下了 30 分钟的时间 😀⏱","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://thinkhard.tech/tags/Lua/"},{"name":"Hammerspoon","slug":"Hammerspoon","permalink":"http://thinkhard.tech/tags/Hammerspoon/"}]},{"title":"升级 Macbook 2015 固态硬盘为  M.2 2280 PCIE NVME 接口 SSD","slug":"macbook2015upgradessd","date":"2019-04-04T11:18:36.000Z","updated":"2019-04-04T12:09:55.475Z","comments":true,"path":"2019/04/04/macbook2015upgradessd/","link":"","permalink":"http://thinkhard.tech/2019/04/04/macbook2015upgradessd/","excerpt":"","text":"升级 Macbook 2015 固态硬盘为 M.2 2280 PCIE NVME 接口 SSD 东西没有坏掉，只有修不好的 由于苹果原装接口 SSD 价格太高(512G ≈ 2000RMB)，采用 M2.0 接口转苹果 SSD 专用接口的转接卡，升级成本在 600RMB 左右。 Macbook 型号 MacBook Pro (Retina, 13-inch, Early 2015) 配置: 8G RAM, 128G SSD 所需材料 NVMe PCIe M.2 转 2015 款 Macbook Pro SSD 转接卡 （￥17） INTEL 760p SSD M.2 2280 PCIE NVME 协议固态 （￥656） 螺丝刀工具盒 更换步骤 制作 MacOS Mojave 启动 U 盘 自行备份旧 SSD 数据 拆解过程请参考 MacBook Pro （13英寸，配备Retina显示屏，2015初期）拆解 五角螺丝刀拆下 SSD，并更换转接卡 安装后盖，插上启动 U 盘，开机按照提示安装 MacOS 系统。 硬盘测速 OK, 安装完毕，再战 5 年。","categories":[],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://thinkhard.tech/tags/MacOS/"},{"name":"Macbook","slug":"Macbook","permalink":"http://thinkhard.tech/tags/Macbook/"}]},{"title":"『Hamerspoon』蓝牙自动开关","slug":"Mac-Bluetooth-Auto-Toggle-when-lock-unlock-screen","date":"2019-03-19T06:08:10.000Z","updated":"2019-04-04T10:10:23.685Z","comments":true,"path":"2019/03/19/Mac-Bluetooth-Auto-Toggle-when-lock-unlock-screen/","link":"","permalink":"http://thinkhard.tech/2019/03/19/Mac-Bluetooth-Auto-Toggle-when-lock-unlock-screen/","excerpt":"","text":"『Hamerspoon』Mac 蓝牙自动开关 前言 如果你也像我一样使用 Mac 连接蓝牙耳机，下班后总是忘记关耳机，第二天耳机没电的话，那么这篇文章也许有用。 当我尝试解决上面这个问题时，写了一个 Python 脚本，但是这并不优雅，直到我找到了 Hammerspoon，从此打开了新世界大门。 首先 Hammerspoon 是什么？ Hammerspoon 是 MacOS 平台上的自动化工具，它不仅仅是应用窗口管理工具，配置 ~/.hammerspoon/init.lua 脚本可以与系统进行交互，这就让这把小锤子的可玩性极高。 在 init.lua 中，注册一系列的回调函数，当监测到事件发生，就能触发对应的回调，例如 按下快捷键事件，快速切换应用； Wi-Fi 连接事件，判断是否到家了； USB 设备连接事件，对插上的设备进行扫描； 电脑休眠和解锁事件; ... 如果使用小锤子，检测到锁屏事件，那么在脚本里就可以自动地对蓝牙进行开关。 在 Mac 上用脚本控制蓝牙开关？ 在 OSX 上，使用 blueutil 可以对蓝牙进行操作 安装方式: brew install blueutil 开启蓝牙: blueutil --power 1 关闭蓝牙: blueutil --power 0 Put Them Together！ 蓝牙切换函数，这里使用 Hammerspoon 运行 Applescript 脚本，然后再在 Applescript 里运行 shell 指令 12345function bluetoothSwitch(state) -- state: 0(off), 1(on) cmd = \"/usr/local/bin/blueutil --power \"..(state) result = hs.osascript.applescript(string.format('do shell script \"%s\"', cmd))end 回调函数 12345678910111213function caffeinateCallback(eventType) if (eventType == hs.caffeinate.watcher.screensDidSleep) then print(\"screensDidSleep\") elseif (eventType == hs.caffeinate.watcher.screensDidWake) then print(\"screensDidWake\") elseif (eventType == hs.caffeinate.watcher.screensDidLock) then print(\"screensDidLock\") bluetoothSwitch(0) elseif (eventType == hs.caffeinate.watcher.screensDidUnlock) then print(\"screensDidUnlock\") bluetoothSwitch(1) endend 监测 Mac 系统睡眠、锁屏等事件 12caffeinateWatcher = hs.caffeinate.watcher.new(caffeinateCallback)caffeinateWatcher:start() 安装 Hammerspoon 配置 首先需要安装 Hammerspoon brew install blueutil git clone https://github.com/wangshub/hammerspoon-config.git ~/.hammerspoon 参考链接 Hammerspoon 文档 What is AppleScript? Lua: Getting started","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://thinkhard.tech/tags/Mac/"},{"name":"Lua","slug":"Lua","permalink":"http://thinkhard.tech/tags/Lua/"},{"name":"Hammerspoon","slug":"Hammerspoon","permalink":"http://thinkhard.tech/tags/Hammerspoon/"}]},{"title":"强化学习之 Deep Q­-Learning","slug":"RLDeepQlearning","date":"2019-03-11T12:27:30.000Z","updated":"2019-04-04T10:10:23.686Z","comments":true,"path":"2019/03/11/RLDeepQlearning/","link":"","permalink":"http://thinkhard.tech/2019/03/11/RLDeepQlearning/","excerpt":"","text":"Deep Q­-Learning Q-Learning 在 Q-Learning 中定义函数 \\(Q(s, a)\\) 表示在当前状态 \\(s\\) 下采取动作 \\(a\\) 获得的最大有损奖励 \\[Q\\left(s_{t}, a_{t}\\right)=\\max R_{t+1}\\] 可以将 \\(Q(s, a)\\) 理解为在一局游戏中，如果在状态 \\(s\\) 下采取动作 \\(a\\) 后，在游戏结束所能获得的最高分。即 Q-函数 表示在某一个状态下采取相应动作的质量。 那么策略 \\(\\pi(s)\\) 就可以表示成在每个状态 \\(s\\) 下选择动作 \\(a\\) 的函数 \\[\\pi(s)=\\operatorname{argmax}_{a} Q(s, a)\\] 许多强化学习算法的基本思想都是通过迭代更新 Bellman 方程来对动作-值进行估计，最佳的得分奖励是由当前环境的即使奖励 \\(r\\) 和下一个状态 \\(s^{\\prime}\\) 的最大奖励的加和。 \\[ Q_{i+1}(s, a)=r+\\gamma \\max _{a^{\\prime}} Q_{i}\\left(s^{\\prime}, a^{\\prime}\\right) \\] Q-Learning 的核心思想：用 Bellman 方程迭代近似估计 Q-函数。一种最简单的方式实现 Q-函数 的方式就是建立一个行为状态，列为动作的表格。 Q-learning 伪代码表示如下 其中 \\(\\alpha\\) 成为学习率，用于控制上一时刻的 Q-值 与下一时刻 Q-值 的差值对更新过程的影响，当 \\(\\alpha=1\\) 时，上式即为 Bellman 方程。 假设在上图中令机器人从起始位置往右移动 1 步，然后计算并更新 Q-值。 当 \\(i \\rightarrow \\infty\\) 时，即可找到最佳动作值函数 \\(Q_{i+t} \\rightarrow Q^{*}\\)。但是在实际当中，每个轨迹序列当中，动作值函数都是被单独估计，不具有任何的泛化的能力。比较常见的方式就是使用(如神经网络)线性或者非线性的估计函数来对动作值函数进行近似估计。 深度 Q 网络(Deep Q Network) 假设状态是一张 64*64 分辨率的图像，那么每个像素点用 8bit 的灰度值表示，那么状态 \\(s\\) 就可能有 \\(256^{64 \\times 64}\\) 种可能，如果构造这么一张巨大无比的 Q-Table，那将是不现实的。 对于高度结构化的数据，正好适合用深度神经网络来对 Q 函数进行近似估计。输入状态 \\(s\\) 和动作，通过网络，输出对应的 Q-值。另一种方式是在 DeepMind 文章中，只是输入当前的状态 \\(s\\), 输出各个 Action 对应的 Q-值。 在 Google DeepMind 的 Paper 中使用了如下的网络结构来对 \\(\\max _{a} \\cdot Q\\left(s^{\\prime}, a^{\\prime}\\right)\\) 进行近似估计 DeepMind 在文章中使用的网络模型如下。 Q 值可能是任意的实数，把对 Q 值的估计看作是机器学习中的回归问题，所以使用 平方误差损失(squared error loss) 作为优化的目标函数。 \\[ L_{i}\\left(\\theta_{i}\\right)=\\mathbb{E}_{\\left(s, a, r, s^{\\prime}\\right) \\sim \\mathrm{U}(D)}\\left[\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right)^{2}\\right] \\] 给定轨迹 \\(&lt;s, a, r, s^{\\prime}&gt;\\) ，使用神经网络替换 Q-Table 过程如下 输入当前状态 \\(s\\)，预测所有动作 \\(a\\) 的 Q-值； 输入下一状态 \\(s\\)，计算最大 \\(\\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime}\\right)\\) 设置 Q 值优化目标为 \\(r+ \\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime}\\right)\\) 反向传播更新网络 weights； 目标 \\(\\max _{a^{\\prime}} Q\\) 取决于神经网络中神经元的权重。监督学习在学习之前，待估计的目标是确定的。 在优化 \\(L_{i}\\left(\\theta_{i}\\right)\\) 时保持上一次迭代参数 \\(\\theta_{i}^{-}\\) 固定不变。 利用随机梯度下降优化损失函数 \\[\\nabla_{\\theta_{i}} L\\left(\\theta_{i}\\right)=\\mathbb{E}_{s, a, r, s^{\\prime}}\\left[\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right) \\nabla_{\\theta_{i}} Q\\left(s, a ; \\theta_{i}\\right)\\right]\\] 经验回放(Exploration-Exploitation) 为什么要经验回放？ 网络是健忘的 参考文献 https://medium.freecodecamp.org/an-introduction-to-q-learning-reinforcement-learning-14ac0b4493cc","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"RL","slug":"RL","permalink":"http://thinkhard.tech/tags/RL/"}]},{"title":"树莓派FM小电台背后的原理解析","slug":"树莓派FM小电台背后的原理解析","date":"2019-02-26T12:53:30.000Z","updated":"2019-04-04T10:10:23.774Z","comments":true,"path":"2019/02/26/树莓派FM小电台背后的原理解析/","link":"","permalink":"http://thinkhard.tech/2019/02/26/树莓派FM小电台背后的原理解析/","excerpt":"","text":"树莓派 FM 发送机小电台背后的原理解析 介绍 在知乎上有个问题 你在 GitHub 上看到过的最有意思的项目是什么？ 我介绍了个很有意思的无线 FM 电台的项目，可以在不借用其他外部设备的情况下，通过代码实现将树莓派变为 FM 小电台。 但是作者只是在博客中介绍了大致的原理。于是我搜遍整个网络，发现大多数的相关文章只是教你如何去编译运行代码，对背后的原理却是只言片语，含糊不清。 作为好奇宝宝，我查阅了许多芯片手册和论坛文章，又翻了翻以前学过的《天线原理》对背后的原理做了一下归纳和总结。 概念名词解释 首先是一些基本的概念 FM: 调频(Frequency Modulation) 是一种以载波的瞬时频率变化来表示信息的调制方式，载波的频率跟随输入信号的幅度直接成等比例变化。FM Radio \b 就是我们熟悉的调频收音机。 PWM: 脉冲宽度调制(Pulse Width Modulation) 是使用数字源生成模拟信号的方法。主要由 2 个参数来定义：占空比和频率。如果以保持一定的速率开关数字信号并且保持一定的占空比，那么输出看起来就像恒定电压模拟信号。 GPIO: 通用型输入输出(General-purpose input/output)，引脚可以由程序控制作为通用输入(GPI)或者通用输出(GPO)。 CPU: 中央处理器(Central Processing Unit)，相当于树莓派的大脑，功能主要是解释计算机指令以及处理计算机软件中的数据，负责与外围设备通信。树莓派使用的是博通 BCM28XX 系列的 CPU。 DMA: 直接内存访问(Direct Memory Access)这些设备可以执行涉及主内存和其他设备的数据传送。由于设备执行这些操作的过程中无需借助于 CPU，因此该类型的数据传送称为直接内存访问。简单说就是不用 \b 跟 CPU 打招呼就可以直接访问内存。 HOW? 根据麦克斯韦的电磁场理论 变化的磁场能够在周围空间产生电场，变化的电场能够在周围空间产生磁场。 随时间均匀变化的磁场(电场)产生稳定电场(磁场)。随时间不均匀变化的磁场(电场)产生变化的电场(磁场)。 变化的电场和变化的磁场总是相互关系着，形成一个不可分割的统一体，这就是电磁场。 随时间变化的电场产生磁场，而随时间变化的磁场又产生电场，两者互为因果。这种不断转化的场统称为电磁场。这种相互的转化形成电磁振荡。 所以如果在树莓派的 GPIO 上，通过软件控制以一定频率输出高低电平(0/1)，再加上适当长度的天线(一根杜邦线即可)就可以将能量以电磁波的形式发射出去。 FM 结构图 由图可知，组成一个 FM 发射机系统，树莓派需要 信号采样和 FM 调制所需的时钟 可以通过编程控制电平变化的 GPIO 一段可以将电磁波发射出去的天线 时钟 目前绝大多数的的微处理器都\b有扩频时钟(Spread-spectrum clock)，目的是为了降低电磁干扰(EMI)，在树莓派 BCM28XX 系列芯片上，扩频时钟的范围为 1MHz 到 250MHz，这正好\b\b用作 FM 的载波信号。 为了减少 CPU 占用，作者对程序进行了改进，使用树莓派 DMA 产生基础时钟。 信号采样 由于 FM 广播发送的是音频信号，所以先使用 228 kHz 的采样频率对信号进行采样(满足奈奎斯特采样定理)，带宽为 15 kHz。 调频 基带信号 \\(x_{m}(t)\\)，载波频率 \\(f_{c}\\)，正弦载波为\\(x_{c}(t)=A_{c} \\cos \\left(2 \\pi f_{c} t\\right)\\) 将基带数据信号与载波结合起来得到了传输信号 \\[ \\begin{aligned} y(t) &amp;=A_{c} \\cos \\left(2 \\pi \\int_{0}^{t} f(\\tau) d \\tau\\right) \\\\ &amp;=A_{c} \\cos \\left(2 \\pi \\int_{0}^{t}\\left[f_{c}+f_{\\Delta} x_{m}(\\tau)\\right] d \\tau\\right) \\\\ &amp;=A_{c} \\cos \\left(2 \\pi f_{c} t+2 \\pi f_{\\Delta} \\int_{0}^{t} x_{m}(\\tau) d \\tau\\right) \\end{aligned} \\] 其中 \\(f(\\tau)\\) 为传输信号的瞬时频率，\\(f_{\\Delta}\\) 为频偏表示相对载波频率 \\(f_{c}\\) 的最大频率偏移。 调频输出的是模拟信号，利用时钟产生 PWM 调整占空比和频率，就可以利用数字信号生成模拟信号。 树莓派天线长度 波长： \\(\\lambda=c/f\\) 偶极子天线：制作偶极子天线时，会通过工作波长来确定天线的长度。最常见的偶极子天线是半波天线，它的总长度近似为工作波长的一半，即 \\(L=\\lambda / 2\\) 如果需要发射 100MHz 的 FM 信号，\b根据上面的公式来计算，就需要 1.5m 长的天线。 12&gt;&gt;&gt; 3*10**8 / (2 * 100 * 10**6)1.5 所以理论上如果给树莓派 GPIO(PIN4) 加上了一根 1.5M 的天线，那么就可以输出最大功率的 FM 信号。 不要这么做，会干扰正常频段！ \b传播距离估计 首先需要计算有效全向辐射功率(EIRP) \\[EIRP = P - Loss +G\\] 其中 \\(P\\) 为发射机的输出功率(\\(dBm\\))，\\(Loss\\) 为发射机输出端与天线馈源之间的馈线损耗(\\(dB\\))，\\(G\\) 为天线的发送增益(\\(dBi\\))。求出 EIRP 后\b可以进而获得自由空间路径损失（Free Space Path Loss，FSPL）。 但是使用这个公式估算，意义不是太大。实际测量，如果使用一根 10cm 的杜邦线作为天线，一个楼梯拐角信号就已经非常弱了。 总结 深深佩服第一个作者的 Geek 范和莫大的脑洞; 不要干扰正常频段，属于违法行为！ 参考 代码请见参考链接 [1] Eben Upton and Gareth Halfacree. Raspberry Pi user guide. John Wiley &amp; Sons, 2014. [2] Oliver Mattos and Oskar Weigl. Turning the Raspberry Pi Into an FM Transmitter. http://www.icrobotics.co.uk/wiki/index.php/Turning the Raspberry Pi Into an FM Transmitter, 2015. [3] Christophe Jacquet. FM-RDS transmitter using the Raspberry Pi’s PWM . https://github.com/ChristopheJacquet/PiFmRds, 2014. [4] Richardson. Turning the Raspberry Pi Into an FM Transmitter. http://www.icrobotics.co.uk/wiki/index.php/Turning_the_Raspberry_Pi_Into_an_FM_Transmitter, 2015. 欢迎关注我的个人公众号","categories":[],"tags":[{"name":"RaspberryPi","slug":"RaspberryPi","permalink":"http://thinkhard.tech/tags/RaspberryPi/"}]},{"title":"用Python给抖音小姐姐打声招呼","slug":"用Python给抖音小姐姐打声招呼","date":"2019-02-20T09:04:28.000Z","updated":"2019-04-04T10:10:23.775Z","comments":true,"path":"2019/02/20/用Python给抖音小姐姐打声招呼/","link":"","permalink":"http://thinkhard.tech/2019/02/20/用Python给抖音小姐姐打声招呼/","excerpt":"","text":"用 Python 自动给抖音小姐姐评论一个 666 前一段时间写了一篇 《抖音 Python 机器人，论如何在抖音上找到漂亮小姐姐？》，没想到有相当多的同学有着相同的需求！\b 大家皆为 程序的基本思路请见 原理与使用教程 当程序在抖音上刷到一个\b漂亮小姐姐的时候就会自动\b点赞加关注 作为一个闷骚程序员，见到漂亮小姐姐总是在背后默默点赞加关注。 但是鲁迅曾经说过 喜欢就要大声说出来！ 于是我又给脚本加上了这么一个自动评论的功能 \b自动评论实现步骤 查阅 ADB 文档\b， adb shell input text \"hello,world\" 命令可直接将字符串输入到 Android App 的输入框中，但是仅支持 ASICC 字符\b，也就是不能够输入中文字符。好在 senzhk 写了一个 ADB \b虚拟键盘输入法，通过监听 ADB \b广播事件接收 ADB 发送的 Unicode 编码字符串，然后输入到文本框中，可以绕过这个\b限制。 \b操作步骤 安卓手机安装 ADBKeyBoard.apk 将手机默认输入法切换为 ADB KeyBoard \b手机连上电脑，在输入框输入 adb shell am broadcast -a ADB_INPUT_TEXT --es msg '可爱小姐姐你好呀' 即可输入中文字符； 代码实现 完整代码请参考 wangshub/Douyin-Bot 12345678910111213def auto_reply(): msg = \"垆边人似月，皓腕凝霜雪。就在刚刚，我的心动了一下，小姐姐你好可爱呀_Powered_By_Python\" tap(config['comment_bottom']['x'], config['comment_bottom']['y']) time.sleep(1) tap(config['comment_text']['x'], config['comment_text']['y']) time.sleep(1) cmd = 'shell am broadcast -a ADB_INPUT_TEXT --es msg &#123;text&#125;'.format(text=msg) adb.run(cmd) time.sleep(1) tap(config['comment_send']['x'], config['comment_send']['y']) time.sleep(0.5) cmd = 'shell input keyevent 4' adb.run(cmd) 存在的问题 ADB 不支持 Unicode 编码，所以需要用 ADB KeyBoard 操作比较繁琐； 再者 ADB 是对屏幕坐标点击，存在屏幕分辨率适配的硬伤； 针对上面的两个问题，可以使用 App 自动化测试工具 Appium 解决，后面再找机会把坑填上； 总结 小孩子不要玩抖音 ！小孩子不要玩抖音！ 太耗时间了，每天在安装了又卸载，卸载了又安装的 Loop 中循环 O_O 送人一赞，手留余香 🌹 作者：神奇的战士 https://github.com/wangshub \b欢迎关注我的\b公众号【神奇的战士】，期待跟你分享有趣的代码 ~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"ADB","slug":"ADB","permalink":"http://thinkhard.tech/tags/ADB/"},{"name":"Douyin","slug":"Douyin","permalink":"http://thinkhard.tech/tags/Douyin/"}]},{"title":"在GitHub上看到过的最有意思的项目","slug":"在GitHub上看到过的最有意思的项目","date":"2019-02-18T07:02:53.000Z","updated":"2019-05-27T00:41:39.469Z","comments":true,"path":"2019/02/18/在GitHub上看到过的最有意思的项目/","link":"","permalink":"http://thinkhard.tech/2019/02/18/在GitHub上看到过的最有意思的项目/","excerpt":"","text":"在GitHub上看到过的最有意思的项目 键盘听声识键 地址：ggerganov/kbd-audio \b\b\b通过麦克风录取键盘的敲击声，判断你按下的是哪个按键。kbd-audio 提供了一整套 GUI 工具，帮助你可视化分析输入的语音数据。从此在输入密码的时候得小心了 -_- 通过 Wi-Fi 信号估计附近有多少人 地址：schollz/howmanypeoplearearound 用一个支持\b监听模式的 USB 网卡，就可以扫描出附近 Wi-Fi 的网络内的设备与信号强度。按照不同国家地区人群拥有\b手机比例，就可以大致估计附近人数。 123456789101112131415161718192021$ howmanypeoplearearound -o test.json -a wlan1[==================================================] 100% 0s leftThere are about 4 people around.$ cat test.json | python3 -m json.tool[ &#123; &quot;rssi&quot;: -86.0, &quot;mac&quot;: &quot;90:e7:c4:xx:xx:xx&quot;, &quot;company&quot;: &quot;HTC Corporation&quot; &#125;, &#123; &quot;rssi&quot;: -84.0, &quot;mac&quot;: &quot;80:e6:50:xx:xx:xx&quot;, &quot;company&quot;: &quot;Apple, Inc.&quot; &#125;, &#123; &quot;rssi&quot;: -49.0, &quot;mac&quot;: &quot;ac:37:43:xx:xx:xx&quot;, &quot;company&quot;: &quot;HTC Corporation&quot; &#125;] 树莓派 FM 发送站 地址：Miegl/PiFmAdv 对音频信号进行 FM 调制，树莓派的 GPIO 口作为天线发射信号，一个小小的私人电台就搭建好了。 注意：私人架设电台是违法行为，不能发射大功率的信号干扰正常的FM频段! Github 仓库代码隐私数据扫描 地址: dxa4481/truffleHog 有相当多的人会在自己的 Github 开源项目中遗留一些账号密码，truffleHog 可以在对 Git 的所有分支和 Commit 记录中搜索密钥等敏感信息。 Wi-Fi 破解 地址：brannondorsey/wifi-cracking \b该项目详细记录了用 Airodump-ng 和 Aircrack-ng/Hashcat 破解 WPA/WPA2 无线 Wi-Fi 路由器的\b过程和思路。 最后还有这个 ... 已删除","categories":[],"tags":[{"name":"Code","slug":"Code","permalink":"http://thinkhard.tech/tags/Code/"},{"name":"Github","slug":"Github","permalink":"http://thinkhard.tech/tags/Github/"}]},{"title":"Vanilla_Policy_Gradient","slug":"Vanilla-Policy-Gradient","date":"2019-01-29T08:48:53.000Z","updated":"2019-04-04T10:10:23.687Z","comments":true,"path":"2019/01/29/Vanilla-Policy-Gradient/","link":"","permalink":"http://thinkhard.tech/2019/01/29/Vanilla-Policy-Gradient/","excerpt":"","text":"\b强化学习 Vanilla Policy Gradient 令 \\(\\pi _ { \\theta }\\) 表示参数为 \\(\\theta\\) 的策略，\\(J \\left( \\pi _ { \\theta } \\right)\\) 表示策略 \\(\\pi _ { \\theta }\\) 的返回值，则优化函数梯度为 \\[\\nabla _ { \\theta } J \\left( \\pi _ { \\theta } \\right) = \\underset { \\tau \\sim \\pi _ { \\theta } } { E } \\left[ \\sum _ { t = 0 } ^ { T } \\nabla _ { \\theta } \\log \\pi _ { \\theta } \\left( a _ { t } | s _ { t } \\right) A ^ { \\pi _ { \\theta } } \\left( s _ { t } , a _ { t } \\right) \\right]\\] 梯度上升 \\[\\theta _ { k + 1 } = \\theta _ { k } + \\alpha \\nabla _ { \\theta } J \\left( \\pi _ { \\theta _ { k } } \\right)\\] 算法伪代码","categories":[],"tags":[{"name":"Reinforcement learning","slug":"Reinforcement-learning","permalink":"http://thinkhard.tech/tags/Reinforcement-learning/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://thinkhard.tech/tags/Algorithm/"}]},{"title":"用Python获取B站播放历史记录","slug":"用Python获取B站播放历史记录","date":"2019-01-22T10:40:22.000Z","updated":"2019-04-04T10:10:23.775Z","comments":true,"path":"2019/01/22/用Python获取B站播放历史记录/","link":"","permalink":"http://thinkhard.tech/2019/01/22/用Python获取B站播放历史记录/","excerpt":"","text":"用 Python 获取 B 站播放历史记录 最近 B 站出了一个年度报告，统计用户一年当中在 B 站上观看视频的总时长和总个数。过去一年我居然在 B 站上看了 2600+ 个视频，总计 251 个小时，居然花了这么多时间，吓得我差点把 Bilibili App 卸载了... \b然而\b我又很好奇，到底我在 B 站上都看了些什么类型 小姐姐 的视频，用几行 Python 代码实现了一下。 \b获取请求 Api 接口与 Cookie 实现起来非常\b容易，获取\b cookie 模拟\b请求即可 使用 chrome 浏览器 登陆 B 站，进入历史记录 https://www.bilibili.com/account/history 在网页任意\b位置，鼠标右键 检查 按照下图所示，进入 Network 页面，筛选框输入 history，对结果进行筛选，\b页面滚轮往下即可看到浏览过程中的历史记录请求的 Header 将 Header 下， cookie 一行的字符串复制出来到一个 cookie.txt 文本里 \bPython 代码实现 伪造浏览器请求 123456789101112131415161718192021222324252627282930313233import jsonimport requestsdef read_cookies_file(filename): \"\"\"read cookie txt file :param filename: (str) cookies file path :return: (dict) cookies \"\"\" with open(filename, 'r') as fp: cookies = fp.read() return cookiesdef get_header(filename): cookie = read_cookies_file(filename) headers = &#123; 'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', 'Connection': 'keep-alive', 'Cookie': cookie, 'Host': 'api.bilibili.com', 'Referer': 'https://www.bilibili.com/account/history', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 ' '(KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' &#125; return headersdef req_get(headers, url): resp = requests.get(url, headers=headers) return json.loads(resp.text) 使用\b cookie 模拟请求 12345678910111213def get_all_bili_history(cookie_file): headers = bilibili.get_header(cookie_file) history = &#123;'all': []&#125; for page_num in range(MAX_PAGE): time.sleep(0.6) url = 'https://api.bilibili.com/x/v2/history?pn=&#123;pn&#125;&amp;ps=&#123;ps&#125;&amp;jsonp=jsonp'.format(pn=page_num, ps=PAGE_PER_NUM) result = bilibili.req_get(headers, url) print('page = &#123;&#125; code = &#123;&#125; datalen = &#123;&#125;'.format(page_num, result['code'], len(result['data']))) if len(result['data']) == 0: break history['all'].append(result) return history 代码非常简单，完整代码在 https://github.com/wangshub/bilibili-history 存在的问题 本来想\b拿到所有的播放记录，做一些统计和预测，但是经过实测，B 站只能\b获取到最近 1000 条或者最近 3 个月的播放记录 如果想获得\b更多，只能做一个监测程序，不停地从接口获取数据 安全问题 尽量不要使用不安全的 wifi 网络，有可能会被别有用心之人获取网络请求的 Package，\b易泄露个人隐私。","categories":[],"tags":[]},{"title":"强化学习:策略梯度算法","slug":"强化学习:策略梯度算法","date":"2019-01-15T11:46:17.000Z","updated":"2019-04-04T10:10:23.772Z","comments":true,"path":"2019/01/15/强化学习:策略梯度算法/","link":"","permalink":"http://thinkhard.tech/2019/01/15/强化学习:策略梯度算法/","excerpt":"","text":"强化学习:策略梯度算法 策略梯度的公式推导 ​ 学习参数化表示的策略 (Parameterized policy), 输入环境状态 $ S $ 来选择动作 \\(a\\) ，这里使用 \\(\\theta \\in \\mathbb { R } ^ { d }\\) 来表示策略的参数向量，因此策略函数表示为 \\[\\pi ( a | s , \\boldsymbol { \\theta } ) = \\operatorname { P_r } \\left\\{ A _ { t } = a | S _ { t } = s , \\boldsymbol { \\theta } _ { t } = \\boldsymbol { \\theta } \\right\\} \\tag{1} \\] 其中时刻 \\(t\\) ，环境状态为 \\(s\\) ，参数为 \\(\\theta\\) ，输出动作 \\(a\\) 的概率为 \\(P_r\\) 因此生成马尔可夫决策过程的一个轨迹（trajectory）\\(\\tau = (\\mathbf { s } _ { 1 } , \\mathbf { a } _ { 1 } , \\dots , \\mathbf { s } _ { T } , \\mathbf { a } _ { T })\\) 的概率为 \\[\\underbrace { p _ { \\theta } \\left( \\mathbf { s } _ { 1 } , \\mathbf { a } _ { 1 } , \\ldots , \\mathbf { s } _ { T } , \\mathbf { a } _ { T } \\right) } _ { \\pi _ { \\theta } ( \\tau ) } = p \\left( \\mathbf { s } _ { 1 } \\right) \\prod _ { t = 1 } ^ { T } \\pi _ { \\theta } \\left( \\mathbf { a } _ { t } | \\mathbf { s } _ { t } \\right) p \\left( \\mathbf { s } _ { t + 1 } | \\mathbf { s } _ { t } , \\mathbf { a } _ { t } \\right) \\tag{2} \\] 更一般地，将策略 \\(\\pi\\) 下生成轨迹 \\(\\tau\\) 的概率表示为 \\[P ( \\tau | \\pi ) = \\rho _ { 1 } \\left( s _ { 1 } \\right) \\prod _ { t = 0 } ^ { T } P \\left( s _ { t + 1 } | s _ { t } , a _ { t } \\right) \\pi \\left( a _ { t } | s _ { t } \\right) \\tag{3}\\] ​ 策略梯度方法的目标就是找到一组最佳的参数 \\(\\theta ^ { \\star }\\) 来表示策略函数使得累计奖励的期望最大，即 \\[\\theta ^ { \\star } = \\arg \\max _ { \\theta } E _ { \\tau \\sim p _ { \\theta } ( \\tau ) } \\left[ \\sum _ { t } r \\left( \\mathbf { s } _ { t } , \\mathbf { a } _ { t } \\right) \\right] \\tag{4}\\] ​ 令累积奖励为 \\(R ( \\tau ) = \\sum _ { t = 1 } ^ { T } r \\left( s _ { t } , a _ { t } \\right)\\) ，设定优化目标 \\(J\\left( \\pi _ { \\theta } \\right)\\) 优化策略参数使得奖励的期望值最大 \\[J\\left( \\pi _ { \\theta } \\right) = \\underset { \\tau \\sim \\pi _ { \\theta } } { \\mathrm { E } } [ R ( \\tau ) ]\\tag{5} \\] 对 \\(J\\left( \\pi _ { \\theta } \\right)\\) 求梯度可得策略梯度 $_ { } J ( ) $ ，公式 (6) 的推导过程请参见链接 \\[\\begin{aligned} \\nabla _ { \\theta } J ( \\theta ) &amp;= \\int \\nabla _ { \\theta } \\pi _ { \\theta } ( \\tau ) r ( \\tau ) d \\tau \\\\&amp;= \\int \\pi _ { \\theta } ( \\tau ) \\nabla _ { \\theta } \\log \\pi _ { \\theta } ( \\tau ) r ( \\tau ) d \\tau \\\\ &amp;= E _ { \\tau \\sim \\pi _ { \\theta } ( \\tau ) } \\left[ \\nabla _ { \\theta } \\log \\pi _ { \\theta } ( \\tau ) r ( \\tau ) \\right]\\end{aligned} \\tag{6}\\] 将策略 (1) 两边取 log 对数，然后带入梯度表达\b式 (6) ，推导策略梯度的公式请参考下图 根据策略 \\(\\pi _ { \\theta }\\) 生成 \\(N\\) 条轨迹如图\b所示 利用上图 \\(N\\) 条轨迹的经验平均对策略梯度进行逼近\b，有公式 (7) (8) \\[J ( \\theta ) = E _ { \\tau \\sim p _ { \\theta } ( \\tau ) } \\left[ \\sum _ { t } r \\left( \\mathbf { s } _ { t } , \\mathbf { a } _ { t } \\right) \\right] \\approx \\frac { 1 } { N } \\sum _ { i } \\sum _ { t } r \\left( \\mathbf { s } _ { i , t } , \\mathbf { a } _ { i , t } \\right) \\tag{7}\\] \\[\\nabla _ { \\theta } J ( \\theta ) \\approx \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } \\left( \\sum _ { t = 1 } ^ { T } \\nabla _ { \\theta } \\log \\pi _ { \\theta } \\left( \\mathbf { a } _ { i , t } | \\mathbf { s } _ { i , t } \\right) \\right) \\left( \\sum _ { t = 1 } ^ { T } r \\left( \\mathbf { s } _ { i , t } , \\mathbf { a } _ { i , t } \\right) \\right) \\tag{8}\\] 其中 \\(N\\) 为轨迹的数量，\\(T\\) 为一条轨迹的长度，假设已知策略 \\(\\pi _ { \\theta }\\) ，那么就可以计算\b出策略的梯度 \\(\\nabla _ { \\theta } \\log \\pi _ { \\theta } ( a | s )\\)。另一方面，根据策略 \\(\\pi _ { \\theta }\\) ，在仿真环境 \\(E\\) 中生成 \\(N\\) 条轨迹的数据，即可\b计算出 (8)，根据梯度上升 对参数 \\(\\theta\\) 进行一步更新，如公式 (9) \\[ \\theta \\leftarrow \\theta + \\alpha \\nabla _ { \\theta } J ( \\theta ) \\tag{9} \\] 总结下来就是： \b增加带来正激励的概率 \b减少带来负激励的概率 策略梯度蒙特卡罗 REINFORCE 算法 根据公式 (7) (8) (9) 可得蒙特卡罗 REINFORCE 算法流程 公式 写成伪代码形式 伪代码 Example: 高斯策略梯度算法 策略属于概率分布，可以用神经网络来表示这种概率分布，输入状态 \\(s\\) ，\b\b神经网络将 \\(s\\) 映射成向量 \\(μ\\)，然后网络输出概率 \\(p ( a | \\mu )\\) 和\b动作采样值 \\(a \\sim p ( a | \\mu )\\)，令 \\(r\\) 为 log 标准差。 \\[ \\mathcal { N } \\left( \\text { mean } = \\text { NeuralNet } \\left( s ; \\left\\{ W _ { i } , b _ { i } \\right\\} _ { i = 1 } ^ { L } \\right) , stdev = exp(r) \\right) \\] 其中 \\(\\mu = [ \\text { mean, stdev } ]\\) 在连续的运动空间中，通常使用高斯策略，假设方差为 \\(\\sigma ^ { 2 }\\) ，策略是高斯的，输入状态 \\(s\\) 输出动作 \\(a\\) \b服从 \\(a \\sim \\mathcal { N } \\left( \\mu ( s ) , \\sigma ^ { 2 } \\right)\\)，\b那么 log 策略\b梯度为 \\[ \\nabla _ { \\theta } \\log \\pi _ { \\theta } ( s , a ) = \\frac { ( a - \\mu ( s ) ) \\phi ( s ) } { \\sigma ^ { 2 } } \\tag{10}\\] 在实际使用高斯策略时，用神经网络来表示，即令 \\(f _ { neural\\ network } \\left( \\mathbf { s } _ { t } \\right) = \\mu ( s _ t )\\)，那么策略 \\(\\pi _ \\theta\\) \\[\\log \\pi _ { \\theta } \\left( \\mathbf { a } _ { t } | \\mathbf { s } _ { t } \\right) = - \\frac { 1 } { 2 } \\left\\| f \\left( \\mathbf { s } _ { t } \\right) - \\mathbf { a } _ { t } \\right\\| _ { \\Sigma } ^ { 2 } + const \\tag{11}\\] 策略的梯度 \\[\\nabla _ { \\theta } \\log \\pi _ { \\theta } \\left( \\mathbf { a } _ { t } | \\mathbf { s } _ { t } \\right) = - \\frac { 1 } { 2 } \\Sigma ^ { - 1 } \\left( f \\left( \\mathbf { s } _ { t } \\right) - \\mathbf { a } _ { t } \\right) \\frac { d f } { d \\theta } \\tag{12}\\] 然后反向传播，\b更新网络参数 \\[- \\frac { 1 } { 2 } \\Sigma ^ { - 1 } \\left( f \\left( \\mathbf { s } _ { t } \\right) - \\mathbf { a } _ { t } \\right) \\left( \\sum _ { t } r \\left( \\mathbf { s } _ { t } , \\mathbf { a } _ { t } \\right) \\right) \\tag{13}\\] 参考链接 Lecture 8: Policy Gradient Policy Gradient Algorithms Reinforcement Learning: An Introduction","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://thinkhard.tech/tags/Algorithm/"}]},{"title":"MLPGaussianPolicy","slug":"MLPGaussianPolicy","date":"2019-01-14T11:42:41.000Z","updated":"2019-04-04T10:10:23.685Z","comments":true,"path":"2019/01/14/MLPGaussianPolicy/","link":"","permalink":"http://thinkhard.tech/2019/01/14/MLPGaussianPolicy/","excerpt":"","text":"MLP Gaussian policy Looks like a Gaussian policy whose mean and std are outputs of a neural network. 参考文献 https://arxiv.org/pdf/1502.05477.pdf","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://thinkhard.tech/tags/Reinforcement-Learning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://thinkhard.tech/tags/Tensorflow/"}]},{"title":"强化学习随机策略之高斯似然数原理与代码实现","slug":"强化学习随机策略之高斯似然数原理与代码实现","date":"2019-01-12T06:47:50.000Z","updated":"2019-04-04T10:10:23.773Z","comments":true,"path":"2019/01/12/强化学习随机策略之高斯似然数原理与代码实现/","link":"","permalink":"http://thinkhard.tech/2019/01/12/强化学习随机策略之高斯似然数原理与代码实现/","excerpt":"","text":"强化学习随机策略之高斯似然数原理与代码实现 一、原理介绍 使用随机策略有两个关键点 从策略当中进行采样，获得动作 \\(a\\) (Action) 计算特定动作的似然数 \\(\\log \\pi _ { \\theta } ( a | s )\\) 什么是多元高斯分布？ 在多元高斯分布中，当协方差矩阵 \\(\\Sigma\\) 只有在对角元素非零，而其余元素为 0 时，成为对角高斯分布。 多元高斯分布（Multivariate Gaussian Distribution）是一元高斯分布的在向量形式上的推广，其中向量 \\(X = \\left[ X _ { 1 } , X _ { 2 } , \\ldots , X _ { n } \\right] ^ { T }\\) 的均值为 \\(\\mu \\in \\mathbf { R } ^ { n }\\) ，协方差矩阵为 \\(\\Sigma \\in S ^ { n }\\) ，概率密度函数表示为 \\[p ( x ; \\mu , \\Sigma ) = \\frac { 1 } { ( 2 \\pi ) ^ { n / 2 } | \\Sigma | ^ { 1 / 2 } } \\exp \\left( - \\frac { 1 } { 2 } ( x - \\mu ) ^ { T } \\Sigma ^ { - 1 } ( x - \\mu ) \\right)\\] 例如二元高斯多元分布可以如图所示 . 对于一对随机变量 \\(X\\) 和 \\(Y\\) ，它们的协方差矩阵写作 \\[\\operatorname { Cov } [ X , Y ] = E [ ( X - E [ X ] ) ( Y - E [ Y ] ) ] = E [ X Y ] - E [ X ] E [ Y ]\\] 对于多个变量的问题，用协方差矩阵 \\(\\Sigma \\in S ^ { n }\\) 来表示各个变量之间的相关性，有 \\[\\Sigma = E \\left[ ( X - \\mu ) ( X - \\mu ) ^ { T } \\right] = E \\left[ X X ^ { T } \\right] - \\mu \\mu ^ { T }\\] 对角多元高斯分布 特殊地，当 N 个随机变量 \\(X = \\left[ X _ { 1 } , X _ { 2 } , \\ldots , X _ { n } \\right] ^ { T }\\) 为各自独立的高斯随机变量时，协方差矩阵为对角阵，即 \\[\\Sigma = \\operatorname { diag } \\left( \\sigma _ { 1 } ^ { 2 } , \\sigma _ { 2 } ^ { 2 } , \\ldots , \\sigma _ { n } ^ { 2 } \\right)\\] 对角高斯策略 Diagonal Gaussian Policies 由于标准差的公式 \\(\\sigma = \\sqrt { \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } \\left( x _ { i } - \\mu \\right) ^ { 2 } }\\) 可知 \\(\\sigma\\) 始终大于等于 0 ，对标准差取 log 对数，可以将标准差映射到 \\(( - \\infty , \\infty )\\)，这样更有利于神经网络的训练。 采样：假设已知动作(Action) 的均值 \\(\\mu _ { \\theta } ( s )\\) 和标准差 \\(\\sigma _ { \\theta } ( s )\\) ，引入服从 \\(( z \\sim \\mathcal { N } ( 0 , I ) )\\) 分布的噪声 \\(z\\) ，下一步的动作采样表示为 \\[a = \\mu _ { \\theta } ( s ) + \\sigma _ { \\theta } ( s ) \\odot z\\] 其中 \\(\\odot\\) 表示两个向量之间的内积。 似然数：当均值为 \\(\\mu = \\mu _ { \\theta } ( s )\\) ，标准差为 \\(\\sigma = \\sigma _ { \\theta } ( s )\\) 的 \\(k-\\)维的动作 \\(a\\) 的似然数表示为 \\[\\log \\pi _ { \\theta } ( a | s ) = - \\frac { 1 } { 2 } \\left( \\sum _ { i = 1 } ^ { k } \\left( \\frac { \\left( a _ { i } - \\mu _ { i } \\right) ^ { 2 } } { \\sigma _ { i } ^ { 2 } } + 2 \\log \\sigma _ { i } \\right) + k \\log 2 \\pi \\right)\\] 二、代码实现 要求 - 输入: 样本 x，对角高斯分布的均值和标准差 - 输出：样本 x 的似然数 123import tensorflow as tfimport numpy as npEPS = 1e-8 根据上一节，似然数公式，理解公式后就很容易写出代码 123456789101112131415161718192021# my solutiondef my_gaussian_likelihood(x, mu, log_std): \"\"\" Args: x: Tensor with shape [batch, dim] mu: Tensor with shape [batch, dim] log_std: Tensor with shape [batch, dim] or [dim] Returns: Tensor with shape [batch] \"\"\" ####################### # # # YOUR CODE HERE # # # ####################### std = tf.exp(log_std) ans = ((x - mu) / std)**2 + 2 * log_std + np.log(2 * np.pi) ans = -0.5 * ans # https://www.tensorflow.org/api_docs/python/tf/math/reduce_sum sum_ans = tf.reduce_sum(ans, axis=1) return sum_ans 12345# standard solution# 代码来自 spinup/exercises/problem_set_1_solutions/exercise1_2_soln.pydef ans_gaussian_likelihood(x, mu, log_std): pre_sum = -0.5 * (((x-mu)/(tf.exp(log_std)+EPS))**2 + 2*log_std + np.log(2*np.pi)) return tf.reduce_sum(pre_sum, axis=1) 1234567891011121314151617181920212223242526if __name__ == '__main__': \"\"\" Run this file to verify your solution. \"\"\" sess = tf.Session() dim = 10 x = tf.placeholder(tf.float32, shape=(None, dim)) mu = tf.placeholder(tf.float32, shape=(None, dim)) log_std = tf.placeholder(tf.float32, shape=(dim,)) your_gaussian_likelihood = my_gaussian_likelihood(x, mu, log_std) true_gaussian_likelihood = ans_gaussian_likelihood(x, mu, log_std) batch_size = 32 feed_dict = &#123;x: np.random.rand(batch_size, dim), mu: np.random.rand(batch_size, dim), log_std: np.random.rand(dim)&#125; your_result, true_result = sess.run([your_gaussian_likelihood, true_gaussian_likelihood], feed_dict=feed_dict) correct = np.allclose(your_result, true_result) print(\"Your answer is\", correct) Your answer is True 参考链接 https://spinningup.openai.com/en/latest/spinningup/rl_intro.html#stochastic-policies https://www.tensorflow.org/api_docs/python/tf/math/reduce_sum","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"http://thinkhard.tech/tags/Reinforcement-Learning/"}]},{"title":"每个会做饭的人都是人生赢家","slug":"每个会做饭的人都是人生赢家","date":"2019-01-11T13:19:55.000Z","updated":"2019-04-04T10:10:23.774Z","comments":true,"path":"2019/01/11/每个会做饭的人都是人生赢家/","link":"","permalink":"http://thinkhard.tech/2019/01/11/每个会做饭的人都是人生赢家/","excerpt":"","text":"摘自 《会做饭的，都是人生赢家》 12345678不紧不慢地做一顿好吃的饭菜，是一场可以避世与收获宁静的禅修；而爱做饭、会做饭的人，也可以称作是有信仰的人。这样的人，生命中会少一些波折。单身的时候，没那么多顾影自怜，结婚以后，也能好好说话。毕竟，谁舍得在一锅香喷喷、热腾腾的萝卜牛腩面前大动干戈？","categories":[],"tags":[]},{"title":"Alfred-Gitlab-Workflow","slug":"Alfred-Gitlab-Workflow","date":"2018-10-12T00:31:33.000Z","updated":"2019-04-04T10:10:23.684Z","comments":true,"path":"2018/10/12/Alfred-Gitlab-Workflow/","link":"","permalink":"http://thinkhard.tech/2018/10/12/Alfred-Gitlab-Workflow/","excerpt":"","text":"Alfred Gitlab Workflow：Gitlab 快速浏览工具 GitLab 是一个类似于 GitHub 的开源源码托管服务，除了代码托管外，\bGitlab 还具备了像 Issue、Merge Requests 等软件协作功能。Gitlab \b有社区版和企业版，能够被部署到私有服务器上，经常在\b\b开发团队中被使用。 Alfred \b是 MacOS 下面相当知名的 App 快速启动工具，最迷人的地方在于通过关键词快速触发一系列\b操作，\b可以将大部分重复机械的操作\b写成 Workflow，极大地提升效率。 在我日常使用 Gitlab 过程中，\b在网页中点击频率最高的莫过于搜索、Issue、Merge Requests、Todo 这几个控件了，它们长这样 但是不会“偷懒”的程序员都不是好程序员，有时候连 Chrome 都不愿意自己伸手点开，所以\b\b对着 Python Alfred Wokflow 库文档，写了一个小插件 一、安装 依赖于 Alfred3 下载 Gitlab workflow release 点击安装 二、配置 url 和 Token \bglurl：设置 Gitlab 的 url gltoken：设置 Gitlab 的 Token 三、功能 glp：\b\b快速浏览和模糊搜索 Gitlab 项目 gli：快速搜索 Gitlab issue glm：快速打开分配给你的 Merge Requests gltodo：在默认浏览器中打开 Todo 页面 四、项目地址 MIT @ \b神奇的战士 https://github.com/wangshub/Alfred-Gitlab-Tool 最后 希望这个工具可以为你剩下一点时间撸猫 ~","categories":[],"tags":[]},{"title":"用Python写Alfred3插件","slug":"用Python写Alfred3插件","date":"2018-09-30T10:18:16.000Z","updated":"2019-04-04T10:10:23.775Z","comments":true,"path":"2018/09/30/用Python写Alfred3插件/","link":"","permalink":"http://thinkhard.tech/2018/09/30/用Python写Alfred3插件/","excerpt":"","text":"用 Python 写 Alfred3 workflow 插件，一个最小示例 以前一直在使用 Cerebro 作为效率\b工具(开源免费)，但是 Cerebro 原作者似乎\b\b很久没有更新，今天抱着试一试的心态用了一把 Alfred 才发现，哎哟握草 Alfred 优化了快速启动与搜索的功能，比 Cerebro 更加丝滑流畅，还引入了 Workflows 这个强大的扩展功能，\b用户可以用自己熟悉的语言比如 python、JavaScript 和 Php 等来\b写 Wokflow。因此赋予了 Alfred 无限的可能性。\b 我查阅了一下 Alfred 的文档，发现添加一个 Workflow 插件竟是如此便捷。 背景 自己平时喜欢浏览 HackerNews，所以希望在 Alfred\b 里面快速浏览今天的热门新闻，搜了一下\b现成的 Alfred 的\b HackerNews \b插件，都十分老旧，好像都不能正常工作。照着 Alfred 官方文档，用 Python 简单写了个 Alfred-HackerNews，通过请求 API 获取 HackerNews 新闻。 使用截图 步骤 创建一个新 Workflow 新建步骤推荐阅读: creating-a-new-workflow 设置关键词触发 Python 脚本，如图所示，当输入 hn 时，就可以执行 /usr/bin/python hn.py 这条 shell 指令，hn.py 就是需要编辑的\b Python 文件。在这个 Workflow 中由于\b没有输入参数，所以我设置了 No Argument。 使用 Alfred-Workflow 库 流程创建完毕后，就需要对代码进行编辑 找到 Workflow 源码路径: 鼠标右键 Hacker-news，\b选择 Show in Finder，找到源码 请求 api.hnpwa.com/v0 获取 HackerNews 数据 1234567891011121314def get_top_news(): base_url = 'https://api.hnpwa.com/v0/&#123;name&#125;/&#123;page&#125;.json' max_pages = 15 name = 'news' result = [] for page in range(1, max_pages): url = base_url.format(name=name, page=page) req = web.get(url) req.raise_for_status() if len(req.json()) == 0: break result = result + req.json() return result 将\b数据封装成 xml 格式返回给 Alfred 123456789101112131415161718192021def main(wf): posts = wf.cached_data('posts', get_top_news, max_age=60*60) # Loop through the returned posts and add an item for each to # the list of results for Alfred for post in posts: subtitle = \"points: &#123;points&#125; | user: &#123;user&#125; | &#123;time_ago&#125; | comments:&#123;comments_count&#125; | &#123;url&#125;\".format( points=post['points'], user=post['user'], time_ago=post['time_ago'], comments_count=post['comments_count'], url=post['url'] ) wf.add_item(title=post['title'], subtitle=subtitle, arg=post['url'], valid=True, icon='./icon.png') # Send the results to Alfred as XML wf.send_feedback() \b为了防止大量请求 API 造成服务器压力，也为了更快地显示结果，将数据进行缓存\b 1posts = wf.cached_data('posts', get_top_news, max_age=60*60) 导出 *.workflow 右键 Hacker-news 将 workflow 导出为 hacker-news.alfredworkflow 格式\b，就可以发布出去啦 总结 \b\b如果使用 Python 第三方库，需要 pip 安装到本地路径 出于兼容性的考虑，Alfred-Workflow 暂时只支持 Python 2，有些小小遗憾； 示例代码\b\b和 Workflow \b下载地址 https://github.com/wangshub/Alfred-HackerNews MIT@神奇的战士","categories":[],"tags":[]},{"title":"在roboschool中控制Atlas","slug":"在roboschool中控制Atlas","date":"2018-09-20T09:28:18.000Z","updated":"2019-04-04T10:10:23.771Z","comments":true,"path":"2018/09/20/在roboschool中控制Atlas/","link":"","permalink":"http://thinkhard.tech/2018/09/20/在roboschool中控制Atlas/","excerpt":"","text":"利用 Python 在 OpenAI 的 roboschool 中控制 Atlas 机器人 作者：神奇的战士 Blog: http://thinkhard.tech/ 背景介绍 Atlas: Atlas 机器人是一个双足人形机器人，由\b鼎鼎大名的美国波士顿动力公司为主开发，身高 1.75 米，体重 82kg，它的出现将人形机器人的发展带到了更高的高度。目前可以完成行走、跑步和翻跟头等一系列复杂的动作。作为机器人当中的贵族，价格自然不菲 T_T (更何况还买不到...)。所以只能通过仿真软件在里面过下干瘾。 Roboschool: Roboschool 是基于 OpenAI Gym 强化学习仿真包的物理仿真引擎。由于 MuJuCo 不开源且收费，所以 OpenAI 的大佬们将 Roboschool 作为 MuJuCo 的替代品。可以\b在一个场景当中训练多个 Agent 并且完成一挑战任务。 软件环境安装 \bRooboschool Gym 示例代码 在 2017 年 7 月 17 号，Roboschool \b发布了 Version 1.1 版本，其中导入了 Atlat 机器人模型，相关新闻可见 NEWS \b所以在安装好\b环境后，可以从 RoboschoolAtlasForwardWalk_v1_2017jul.py 中找到控制 Atlas 前进走路的源码。 RoboschoolAtlasForwardWalk_v1_2017jul.py 仿真 Python 运行代码，由于在 \bTrain 的时候，没有对机器人上肢运动进行约束和\b优化，只关注了下肢的移动，\b最终训练的结果有点辣眼睛，我们可以看到一段魔性嚣张的步伐 1python3 RoboschoolAtlasForwardWalk_v1_2017jul.py 鼠标左键 ： \b旋转镜头 鼠标右键 ： 镜头平移 按键 F1 : 开/关 慢动作 按键 F2 : 隐藏/显示 \b仿真步数和\b累积 Rewards 按键 F3 : 隐藏/显示 \bAction 和 Observation 在 机器人强化学习之使用 OpenAI Gym 教程与笔记 中介绍过使用导入 Gym 模型和查看 Observation \b和 Action 的相关参数，对于 Atlas 也同样适用： 12345import roboschoolimport gymenv = gym.make(\"RoboschoolAtlasForwardWalk-v1\")print('action_space = ', env.action_space)print('observation_space = ', env.observation_space) 输出 12action_space = Box(30,)observation_space = Box(70,) 从 env.action_space 和 env.observation_space 可知 Action 维度为 30，Observation 维度为 70。 \bAction 可以理解为机器人有 30 个自由度，可以通过 PD 控制器控制关节角度； Observation 为当前环境的观测向量； 至于Atlas 机器人 Action 和 Observation 详细解释，在 \bRoboschool 的 Wiki 中没有相关说明，OpenAI 的开发者建议用户靠猜的方式来确定 :)。 确定方式为 修改 Roboschool 源码，将 gym_atlas.py 重力修改为 0 \b按照排除\b法，控制变量 Action，然后 env.step(action) ，分别记下向量每个元素对应的自由度关节。 代码说明 Roboschool 开发者解释到由于强化学习训练 Atlas \b走路的代码太杂乱了，\b所以暂时没有 Train 的代码，所以求人不如求己，后面得自己撸代码 ~\b 总体思路是获得 weight 矩阵，即最佳 Policy，输入当前观测向量 Observation 获得下一步的 Action 向量来控制 Atlas 行走。 总结 Roboschool 这个项目适合验证一些简单的强化学习任务，对于新引入的模型\b支持得还不太友好。 基本上没有什么成体系的说明文档，\b所以需要靠多阅读 Roboschool \b和 Gym\b 的 Python 源码来使用。","categories":[],"tags":[]},{"title":"将 Kindle 转换成文艺电子时钟","slug":"turn-kindle-to-electron-clock","date":"2018-08-05T02:30:01.000Z","updated":"2019-04-04T10:10:23.769Z","comments":true,"path":"2018/08/05/turn-kindle-to-electron-clock/","link":"","permalink":"http://thinkhard.tech/2018/08/05/turn-kindle-to-electron-clock/","excerpt":"","text":"破解 Kindle，改造成文艺电子时钟 前言 原材料准备 硬件 亚马逊 Kindle 6 inch Micro USB 线 软件 \bSSH 工具 破解 Kindle 为了让 Kindle 显示我们想要的内容，需要\b能够登录进 Kindle 系统并且修改系统文件与配置。所以需要将 Kindle 进行越狱操作。 越狱说明请见 Kindle Screen Saver Hack Kindle 上的软件安装包请见 software custom 参考链接 https://www.instructables.com/id/Literary-Clock-Made-From-E-reader/","categories":[],"tags":[]},{"title":"机器人强化学习之使用 OpenAI Gym 教程与笔记","slug":"机器人强化学习之使用 OpenAI Gym 教程与笔记","date":"2018-07-27T02:34:40.000Z","updated":"2019-04-04T10:10:23.773Z","comments":true,"path":"2018/07/27/机器人强化学习之使用 OpenAI Gym 教程与笔记/","link":"","permalink":"http://thinkhard.tech/2018/07/27/机器人强化学习之使用 OpenAI Gym 教程与笔记/","excerpt":"","text":"机器人强化学习之使用 OpenAI Gym 教程与笔记 除了试图直接去建立一个可以模拟成人大脑的程序之外， 为什么不试图建立一个可以模拟小孩大脑的程序呢?如果它接 受适当的教育，就会获得成人的大脑。 — 阿兰·图灵 介绍 强化学习 (Reinforcement learning) 是机器学习的一个子领域用于制定决策和运动自由度控制。强化学习主要研究在复杂未知的环境中，智体(agent)实现某个目标。强化学习最引人入胜的两个特点是 强化学习非常通用，可以用来解决需要作出一些列决策的所有问题：例如，训练机器人跑步和弹跳，制定商品价格和库存管理，玩 Atari 游戏和棋盘游戏等等。 强化学习已经可以在许多复杂的环境中取得较好的实验结果：例如 Deep RL 的 Alpha Go等 Gym 是一个研究和开发强化学习相关算法的仿真平台。 无需智体先验知识； 兼容常见的数值运算库如 TensorFlow、Theano 等 Gym 的一个最小例子 CartPole-v0 123456import gymenv = gym.make('CartPole-v0')env.reset()for _ in range(1000): env.render() env.step(env.action_space.sample()) # take a random action 运行效果 至此，第一个 Hello world 就算正式地跑起来了！ 观测(Observations) 在第一个小栗子中，使用了 env.step() 函数来对每一步进行仿真，在 Gym 中，env.step() 会返回 4 个参数： 观测 Observation (Object)：当前 step 执行后，环境的观测(类型为对象)。例如，从相机获取的像素点，机器人各个关节的角度或棋盘游戏当前的状态等； 奖励 Reward (Float): 执行上一步动作(action)后，智体(agent)获得的奖励(浮点类型)，不同的环境中奖励值变化范围也不相同，但是强化学习的目标就是使得总奖励值最大； 完成 Done (Boolen): 表示是否需要将环境重置 env.reset。大多数情况下，当 Done 为 True 时，就表明当前回合(episode)或者试验(tial)结束。例如当机器人摔倒或者掉出台面，就应当终止当前回合进行重置(reset); 信息 Info (Dict): 针对调试过程的诊断信息。在标准的智体仿真评估当中不会使用到这个 info，具体用到的时候再说。 总结来说，这就是一个强化学习的基本流程，在每个时间点上，智体执行 action，环境返回上一次 action 的观测和奖励，用图表示为 智体与环境交互 在 Gym 仿真中，每一次回合开始，需要先执行 reset() 函数，返回初始观测信息，然后根据标志位 done 的状态，来决定是否进行下一次回合。代码表示为 123456789101112import gymenv = gym.make('CartPole-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation, reward, done, info = env.step(action) if done: print(\"Episode finished after &#123;&#125; timesteps\".format(t+1)) break 仿真截图如下 每次 action 前，将上一次 observation 打印，可以得到打印日志如下 1234567891011[ 0.0349103 1.14771978 -0.03934506 -1.64631971][ 0.0578647 1.34327926 -0.07227145 -1.95099638][ 0.08473028 1.14899616 -0.11129138 -1.68156178][ 0.1077102 0.95532555 -0.14492261 -1.42550525][ 0.12681672 1.15191062 -0.17343272 -1.75974995][ 0.14985493 0.95912509 -0.20862772 -1.52564382]Episode finished after 16 timesteps[ 0.03628829 -0.03189712 -0.01997778 0.02529094][ 0.03565035 -0.22672696 -0.01947196 0.31160431][ 0.03111581 -0.42156616 -0.01323988 0.59808332][ 0.02268449 -0.61650037 -0.00127821 0.8865666 ] 空间（Spaces） 在前面的两个小栗子中，每次执行的动作(action)都是从环境动作空间中随机进行选取的，但是这些动作 (action) 是什么?在 Gym 的仿真环境中，有运动空间 action_space 和观测空间 observation_space 两个指标，程序中被定义为 Space 类型，用于描述有效的运动和观测的格式和范围。下面是一个代码示例 123456import gymenv = gym.make('CartPole-v0')print(env.action_space)#&gt; Discrete(2)print(env.observation_space)#&gt; Box(4,) \u001b[33mWARN: gym.spaces.Box autodetected dtype as &lt;class &#39;numpy.float32&#39;&gt;. Please provide explicit dtype.\u001b[0m Discrete(2) Box(4,) 从程序运行结果来看 action_space 是一个离散 Discrete 类型，从 discrete.py 源码可知，范围是一个 {0,1,...,n-1} 长度为 n 的非负整数集合，在 CartPole-v0 例子中，动作空间表示为 {0,1}。 observation_space 是一个 Box 类型，从 box.py 源码可知，表示一个 n 维的盒子，所以在上一节打印出来的 observation 是一个长度为 4 的数组。数组中的每个元素都具有上下界。 12print(env.observation_space.high)print(env.observation_space.low) [4.8000002e+00 3.4028235e+38 4.1887903e-01 3.4028235e+38] [-4.8000002e+00 -3.4028235e+38 -4.1887903e-01 -3.4028235e+38] 利用运动空间和观测空间的定义和范围，可以将代码写得更加通用。在许多仿真环境中，Box 和 Discrete 是最常见的空间描述，在智体每次执行动作时，都属于这些空间范围内，代码示例为 12345from gym import spacesspace = spaces.Discrete(8) # Set with 8 elements &#123;0, 1, 2, ..., 7&#125;x = space.sample()print(space.contains(x)) print(space.n == 8) True True 在 CartPole-v0 栗子中，运动只能选择左和右，分别用 {0,1} 表示 Gym 中可用的环境 Gym 中从简单到复杂，包含了许多经典的仿真环境和各种数据，其中包括 经典控制和文字游戏：经典的强化学习示例，方便入门； 算法：从例子中学习强化学习的相关算法，在 Gym 的仿真算法中，由易到难方便新手入坑； 雅达利游戏：利用强化学习来玩雅达利的游戏。Gym 中集成了对强化学习有着重要影响的 Arcade Learning Environment，并且方便用户安装； 2D 和 3D 的机器人：这个是我一直很感兴趣的一部分，在 Gym 中控制机器人进行仿真。需要利用第三方的物理引擎如 MuJoCo 。 注册表 Gym 是一个包含各种各样强化学习仿真环境的大集合，并且封装成通用的接口暴露给用户，查看所有环境的代码如下： 12from gym import envsprint(envs.registry.all()) 1dict_values([EnvSpec(Copy-v0), EnvSpec(RepeatCopy-v0), EnvSpec(ReversedAddition-v0), EnvSpec(ReversedAddition3-v0), EnvSpec(DuplicatedInput-v0), EnvSpec(Reverse-v0), EnvSpec(CartPole-v0), EnvSpec(CartPole-v1), EnvSpec(MountainCar-v0), EnvSpec(MountainCarContinuous-v0), EnvSpec(Pendulum-v0), EnvSpec(Acrobot-v1), EnvSpec(LunarLander-v2), EnvSpec(LunarLanderContinuous-v2), EnvSpec(BipedalWalker-v2),... Gym 支持将用户制作的环境写入到注册表中，需要执行 gym.make() 和在启动时注册 register，例如 123456register( id='CartPole-v0', entry_point='gym.envs.classic_control:CartPoleEnv', max_episode_steps=200, reward_threshold=195.0,) 参考链接 https://gym.openai.com/docs/ https://nndl.github.io/ 结语 emmmm ... 第一篇强化学习入坑笔记写完，大多是从官方文档看过来的加上了一点点自己的理解，建议文档这东西还是直接看官方的吧，原汁原味 关于作者 神奇的战士 博客：http://thinkhard.tech/ Github: https://github.com/wangshub 微信公众号：神奇的战士","categories":[],"tags":[]},{"title":"机器人强化学习笔记（0）","slug":"强化学习笔记","date":"2018-07-03T14:34:36.000Z","updated":"2019-04-04T10:10:23.772Z","comments":true,"path":"2018/07/03/强化学习笔记/","link":"","permalink":"http://thinkhard.tech/2018/07/03/强化学习笔记/","excerpt":"","text":"机器人强化学习笔记（0） 机器学习分类 Machine Learning 强化学习\b问题 RL problem Child walk 监督学习：监督学习由任务驱动，需要创造外部的“导师”，“导师”拥有外部环境的所有先验信息，并教导 Agent 完成特定的任务。但是 Agent \b可以用很多种子任务相结合的方式去完成相同的任务。\b所以创造一个全能的“导师”来训练 Agent \b在实际中几乎是不可能的。 非监督学习：非监督学习是由数据驱动，主要目的是\b找到底层的模式而不是映射关系。例如给用户\b推荐新闻时，非监督学习主要是根据用户先前阅读过的新闻\b来推荐相似的新闻。 强化学习：和上面两种\b方法相比较，强化学习主要是从自身的经验来获取知识，在输入和输出之间存在着映射关系。强化学习\b将奖励函数作为行为的反馈。\b \b解决强化学习问题的框架和算法 强化学习需要平衡 exploration vs exploitation 困境。 \b马尔可夫决策过程(Markov Decision Process) 在强化学习场景下，\b数学模型为马尔可夫决策过程，表示为 状态集合：S 动作集合：A 奖励函数：R 策略：Pi 值：V 从起始状态到结束状态\\(S\\)需要经过动作集合 A。执行每个动作后，都会获得奖励 R，每个动作可能会导致好的或者坏的奖励函数值。策略(Policy)就是\b采取某个系列动作的\b方法，并且会相应的得到奖励函数的值。因此，求解强化学习的目标就是要选取最佳策略(Policy)，在所有可能的状态和时间范围内使得评估函数最大，\b即 最短路径问题(Shortest Path Problem) 求解以最小代价，从地点 A 到地点 F 的最短路径问题，转化为 节点集合 {A, B, C, D, E, F} 从\b\b点到点移动成为动作，{A-&gt;B, C-&gt;D} \b奖励函数为每条边的花费\b 完成 A 点到 F 行走路线成为策略，如 {A-&gt;B-&gt;D-&gt;F}","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Reinforment Learning","slug":"Reinforment-Learning","permalink":"http://thinkhard.tech/tags/Reinforment-Learning/"}]},{"title":"效率工具网站推荐","slug":"工具网站推荐","date":"2018-06-09T01:58:48.000Z","updated":"2019-04-04T10:10:23.771Z","comments":true,"path":"2018/06/09/工具网站推荐/","link":"","permalink":"http://thinkhard.tech/2018/06/09/工具网站推荐/","excerpt":"","text":"提升生活品质——个人效率工具与资讯网站推荐 这个世界上软件太多，懂你的工具太少； 我是个工具控，经常搜集和\b自己写一些工具和插件来提高生活品质； 本文\b将持续更新和记录我平时工作中重度使用的一些\b效率工具和网站； 工具类 Emacs 地址\b：https://github.com/syl20bnr/spacemacs 推荐指数：⭐️⭐️⭐️⭐️⭐️ 目前用到 Emacs 最多的功能就是 Org mode，用于平时的\b想法收集、思路整理、任务分配。Emacs 功能实在强大，任何能想到的功能基本上都有插件，\b但是刚开始上手会非常不习惯。要想全面掌握，还是要看一些 Lisp。 \bOrg mode \b地址：https://orgmode.org/ 推荐指数：⭐️⭐️⭐️⭐️⭐️ 鉴于 Org mode 实在是太好用了，所以再单独推荐一次。\bOrg mode 是基于节点的结构，利用它可以实现脑图的功能，而且还可以设置每个节点的状态。大多数人(包括我)都是将它作为 GTD 工具来使用，或者可以用来写博客文章。 Brook 地址：https://github.com/txthinking/brook 推荐指数：⭐️⭐️⭐️⭐️ Brook 是一个跨平台的代理工具，作者编译出了各个平台的 Release，在我试过 Brook 协议后，一下子被惊艳到了，代理速度十分惊艳，瞬间我的龟速服务器焕发青春。本来想给 Brook 五星的，但是由于目前它的客户端还不太完善，偶尔存在服务端退出的问题。后续还会持续关注该项目。 Typora 地址：https://typora.io/ 推荐指数：⭐️⭐️⭐️⭐️ 像我这种 Markdown 业余程序员，写的最多很多时候却是文档。Typora 是一个精而美的开源跨平台 Markdown 编辑器，支持 MacOS 、Windows、Linux，\b对 Markdown \b渲染是我见过较为漂亮的，输入的体验也超级棒，同时还可以输出 Pdf 文件。 PicGo 地址：https://github.com/Molunerfinn/PicGo 推荐指数：⭐️⭐️⭐️⭐️⭐️ 一个开源免费图床上传工具，PicGo 目前支持了微博图床，七牛图床，腾讯云 COS v4 Cerebro 地址：https://github.com/KELiON/cerebro 推荐指数：⭐️⭐️⭐️⭐️ 一个开源免费\b的对话式快速启动工具，支持 MacOs、Windows、Linux。目前我在 MacOs 下面切换窗口启动软件都离不开这个工具，还为 Cerebro 写了很多插件。当然类似的工具还有 Alfred 和 Wox 等，但是一个能自己\b随心所欲修改的软件才是好软件，对吧？ \bShareMouse 地址：http://www.keyboard-and-mouse-sharing.com/ \b推荐指数：⭐️⭐️⭐️⭐️ 如果\b你需要在不同系统和电脑之间共享同一个键盘鼠标的话，ShareMouse \b可能就是完美地解决方案，但是需要收费。相对于 Synergy，可以在\b不同窗口之间拖拽和复制文件，美中不足\b的是\b需要收费不开源。 Fish Shell 地址：https://fishshell.com/ 推荐指数：⭐️⭐️⭐️⭐️ 相较于 Zsh Shell，我认为 Fish \b在配置上面更人性化一些，但是有一个槽点就是对 Bash 的指令不完全兼容。推荐使用 Oh-my-fish 和 Fisherman 来进行 Fish 的插件管理。推荐 主题 Agnoster + 配色 Dracula，\b好看到没朋友。 资讯网站 Github 每日 Trending 地址: https://github.com/trending 推荐指数：⭐️⭐️⭐️⭐️⭐️ 每天必须要浏览一遍，能上 Github Trending 的项目\b，必定存在着\b创意和骚操作（有幸上过两次月榜）。 Hacker News 地址：https://news.ycombinator.com/ 推荐指数：⭐️⭐️⭐️⭐️⭐️ 在 Hacker News 热榜上面的新闻，绝对算得上技术界的大新闻，强烈值得每日浏览(需要梯子)。 总结 \b工具或者软件，适合自己才是最好的。\b单纯的夸耀某某语言或者 IDE 是最好的，实在没有太大的必要。 一些技术新闻资讯，还是建议多看英文的\b原文链接，很多中文的营销号只是粗略的翻译和转载，在这个过程中，原有的信息可能发生扭曲和丢失，实在像\b被人咀嚼过的甘蔗，没有太多的营养。 最后欢迎关注我的微信公众号：神奇的战士","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://thinkhard.tech/tags/Tool/"}]},{"title":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","slug":"Python抖音机器人，论如何在抖音上找到漂亮小姐姐？","date":"2018-05-28T06:38:32.000Z","updated":"2019-04-04T10:10:23.686Z","comments":true,"path":"2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","link":"","permalink":"http://thinkhard.tech/2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/","excerpt":"","text":"如何在抖音上找到漂亮小姐姐----抖音机器人 最近沉迷于抖音无法自拔，常常花好几个小时在抖音漂亮小姐姐身上。 为了高效、直接地找到漂亮小姐姐，我用 Python + ADB 做了一个 Python 抖音机器人 Douyin-Bot。 特性 自动翻页 颜值检测 人脸识别 自动点赞 自动关注 随机防 Ban 自动回复 原理 打开《抖音短视频》APP，进入主界面 获取手机截图，并对截图进行压缩 (Size &lt; 1MB)； 请求 人脸识别 API； 解析返回的人脸 Json 信息，对人脸检测切割； 当颜值大于门限值 BEAUTY_THRESHOLD时，点赞并关注； 下一页，返回第一步； 使用教程 相关软件工具安装和使用步骤请参考 wechat_jump_game 和 Android 和 iOS 操作步骤 获取源码：git clone https://github.com/wangshub/Douyin-Bot.git 进入源码目录： cd Douyin-Bot 安装依赖： pip install -r requirements.txt 运行程序：python douyin-bot.py 注意 目前暂时只适配了 一加5(1920x1080 分辨率)，如果手机不是该分辨率，请修改 config/ 文件夹下面的配置文件； 脸部截取 LICENSE MIT 欢迎 Star 和 Fork ~ 项目地址:https://github.com/wangshub/Douyin-Bot","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"ADB","slug":"ADB","permalink":"http://thinkhard.tech/tags/ADB/"}]},{"title":"给博客网站加个球(访客统计)","slug":"给博客加个球-访客统计","date":"2018-05-20T09:09:18.000Z","updated":"2019-04-04T10:10:23.776Z","comments":true,"path":"2018/05/20/给博客加个球-访客统计/","link":"","permalink":"http://thinkhard.tech/2018/05/20/给博客加个球-访客统计/","excerpt":"","text":"给博客网站加个球-访客统计脚本 最近无意中发现了 Revolvermaps 这个网站，可以对网站页面上的访客进行统计。 Demo 演示 神奇的战士的博客 主要特征 访客 IP 地点统计； 访客人数\b统计； 页面停留时间统计； 多样式定制； 免费、易使用； \b使用方法 访问 https://www.revolvermaps.com 复制脚本代码 \b插入到博客网站中的 Html； 效果展示 过去 24 小时访客统计 不同地区统计 \b各地区\b访问人数 各个地区的访问时间 最后 Happy 520 Day ~","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://thinkhard.tech/tags/Blog/"}]},{"title":"使用Emacs进行日程管理（GTD）","slug":"使用Emacs进行日程管理（GTD）","date":"2018-05-13T06:19:22.000Z","updated":"2019-04-04T10:10:23.770Z","comments":true,"path":"2018/05/13/使用Emacs进行日程管理（GTD）/","link":"","permalink":"http://thinkhard.tech/2018/05/13/使用Emacs进行日程管理（GTD）/","excerpt":"","text":"使用 Emacs 进行日程管理 (GTD) 什么是 GTD ? Your mind is for having ideas, not holding them. --- David Allen GTD (Getting Things Done) 是一个组织和跟进任务或待办事项的系统架构，但是它的目标要高于仅仅是将事情做完，而是要将待办事项以一个更好的方式完成。GTD 的目标是让人 100% 地相信 GTD 的系统来收集任务、想法。这样才能卸下记忆这些想法的思想包袱，专注的完成当下的任务。GTD 将所有的事情罗列下来，然后再进行分类，你就能从一个比较宏观的角度来看待这一堆问题，并且确定下一步的处理方法，将所有悬而未决的事情尽量地处于我们个人的掌握之中。 更多关于 GTD 方法的介绍可以参考 David Allen 的博客和相关书籍。 理论就介绍到这里了，目前市面上有许许多多在各种平台上收费 GTD 任务管理软件、也有许多开源免费的软件，如 Taskwarrior Todo.txt Emacs Org-mode ... 今天主要 Show 一下在 Emacs 中使用 Org-mode 来记录、分类、保存、跟进我的想法和任务 主要特点 基于 Spacemacs 功能强大； 操作难度较大，可定制性强； 利用 Git 工具定期自动备份笔记； Emacs 插件安装步骤 项目地址：https://github.com/carlos-wong/org-agenda-carlos 在 Emacs 中进行日程管理 安装并配置好插件后，使用时主要分三步：\b录入、显示、保存。 Todo 录入 绑定输入快捷键：F7 绑定显示快捷键：F6 选择 Todo 类型 输入事项 安排节点 Todo 显示 结语 现在，每天打开 Emacs 的第一件事就是看今天的 Org ,又有做不完的事情了 ~","categories":[],"tags":[{"name":"Emacs","slug":"Emacs","permalink":"http://thinkhard.tech/tags/Emacs/"},{"name":"Lisp","slug":"Lisp","permalink":"http://thinkhard.tech/tags/Lisp/"}]},{"title":"开源跨平台效率软件Cerebro","slug":"跨平台效率软件Cerebro","date":"2018-04-30T12:26:25.000Z","updated":"2019-04-04T10:10:23.776Z","comments":true,"path":"2018/04/30/跨平台效率软件Cerebro/","link":"","permalink":"http://thinkhard.tech/2018/04/30/跨平台效率软件Cerebro/","excerpt":"","text":"开源跨平台效率软件Cerebro 开源跨平台效率软件Cerebro 主要特性 功能展示 \b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发 \b插件展示 我们写的一些插件 Cerebro-torrent Cerebro-codelf 结语 在 Mac 下面有很多制作精美的第三方软件，其中就有大名鼎鼎的效率神器 Alfred 。但是只能在 Mac 下面才能使用，而且收费不开源。 今天隆重介绍一下另一款大杀器 Cerebro 以及我是如何在平时工作学习中使用它提升效率的。 不同于菜单，Ui 交互的工作方式，\b类似接自然对话的交互方式，这类对话式的操作软件还是有不少项目，但是跨平台、插件开发来说 Cerebro 是比较出色的，毕竟一个能让自己任意修改的软件才是好软件。@carlos-wong 主要特性 \b美好的生活从 Ctrl-Space 开始； App 快速启动； 电脑文件搜索； \b基于 JavaScript, 一定要试试自己写插件； 跨平台 Mac、Windows、Linux； 做你能想到的任何事； 理论上 Alfred 能做的事情，Cerebro 同样能做到，更重要的是 跨平台开源免费！、跨平台开源免费！、跨平台开源免费！ 功能展示 \b应用与文件搜索 基于 Electron，什么都能看 易上手的插件开发 如果你正好是 JavaScript 的爱好者的话，这款\b软件绝对是你的大杀器，Cerebro \b的插件是同类软件中最容易上手开发的。只需要遵从 Cerebro API ，如果你连文档都懒得看的话，\b个人建议直接从插件列表 Awesome-cerebro 选一个改成你想要的样子就行，开源就是这么有魅力！ \b插件展示 密码管理 执行 Shell 命令 shell 搜索 npm 包 \b生成\b二维码 搜索 Emoji 表情 更多插件列表 Awesome-cerebro 我们写的一些插件 Cerebro-torrent 我写的种子搜片儿神器 Cerebro-torrent &gt; 看个片儿还要打开网页慢慢找?！ Cerebro-codelf [@carlos-wong](https://github.com/carlos-wong) 制作快速地变量名搜索神器 Cerebro-codelf &gt; 给变量起名的事情上，为你生命省 3s 结语 如果你生活中存在着一些机械重复的\b劳动的话，比如煮个咖啡、回复相同内容的邮件、\b打开特定的网页等等，完全可以写成 Cerebro 插件提升效率，而节省下来的时间再用来改进工具，形成正循环！ 欢迎入坑 ~","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://thinkhard.tech/tags/JavaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://thinkhard.tech/tags/Cerebro/"}]},{"title":"cerebro-codelf给变量起名的事情上，为你生命省3s","slug":"cerebro-codelf给变量起名的事情上，为你生命省3s","date":"2018-04-30T12:11:27.000Z","updated":"2019-04-04T10:10:23.691Z","comments":true,"path":"2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","link":"","permalink":"http://thinkhard.tech/2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/","excerpt":"","text":"cerebro-codelf There are only two hard things in Computer Science: cache invalidation and naming things. -- Phil Karlton 给变量起名的事情上，为你生命省 3s。 Cerebro 变量名搜索插件，项目灵感来源 codelf。通过 Cerebro 的搜索窗口快速查找变量名。 特性 快速启动、搜索 中英文搜索 自由定制 安装 插件依赖于 Cerebro Ctrl-Space 打开 Cerebro 输入 plugins codelf，点击安装 使用 Cerebro 中，输入 codelf + [待搜索的变量名]； 上下选择变量名，敲回车 Enter 复制到剪切板； LICENSE MIT 项目地址 https://github.com/carlos-wong/cerebro-codelf 欢迎 fork :fork_and_knife: 和 star :star:","categories":[],"tags":[{"name":"JacaScript","slug":"JacaScript","permalink":"http://thinkhard.tech/tags/JacaScript/"},{"name":"Cerebro","slug":"Cerebro","permalink":"http://thinkhard.tech/tags/Cerebro/"}]},{"title":"python插件式爬虫","slug":"python插件式爬虫","date":"2018-04-25T07:51:05.000Z","updated":"2019-04-04T10:10:23.768Z","comments":true,"path":"2018/04/25/python插件式爬虫/","link":"","permalink":"http://thinkhard.tech/2018/04/25/python插件式爬虫/","excerpt":"","text":"Python 插件式的信息爬虫 🐝 一群不辞劳苦采花小蜜蜂 项目代码地址 本项目运行在可以运行在本地或者服务器端，将不同插件程序获取的信息如：每日天气、新闻等，通过 Github Api 上传到仓库进行保存。当然，你还可以你日常机械重复性的劳动在插件中帮你完成，比如煮咖啡、发邮件等等，真是棒极了。 额外收获 ：定期稳定运行在服务器上，还可以每日贡献一次 Github 贡献度 ... 点亮你的人生！ 工程说明 12345678├── app│ └── plugins│ └── weather.py├── builtin_plugins├── config│ └── config.json├── main.py└── upload_github.py main.py : 加载 builtin_plugins/ 和 app/ 下的插件； app/plugins/ : 插件程序存放路径； builtin_plugins ： 内置插件路径； upload_github.py : 通过 Github Api 提交一次 Commit； 使用步骤 生成 Github Token 运行代码 1python main.py 插件接口 Json 格式 可以自己补充插件，各个插件的返回值为字典类型，必须满足如下格式 12345678&#123; \"code\": 0, \"type\": \"weather\", \"date\": \"2018-04-23 20:18:03\", \"content\": &#123; \"city\": \"\\u6df1\\u5733\", \"weather\": \"\\u591a\\u4e91\", \"temperature\": \"21 ~ 26\\u2103\", \"humidity\": \"\\u6e7f\\u5ea6\\uff1a63%\", \"wind\": \"\\u98ce\\u5411\\uff1a\\u5317\\u98ce 2\\u7ea7\", \"radiation\": \"\\u7d2b\\u5916\\u7ebf\\uff1a\\u5f31\", \"air\": \"PM: 43\" &#125;&#125; 参数说明 code: 0 成功、-1 失败； type: 例如 [weather, stock, news] 等； date: 当天日期，如 2018-05-01； content: 获取的 Json 格式信息，这部分提交到仓库保存； Todo Python 插件化信息管理，可拓展； 信息保存到 Github 仓库； 更多插件补充； Docker一键部署到本地或服务器； 信息可视化 Pyeacharts 网页显示 Gitpage 静态页面每日渲染 Itchat 微信推送 自动登录 自动推送 信息查询 补充插件内容 插件思路收集 大新闻日常备份 商品价格记录插件","categories":[],"tags":[]},{"title":"Python插件式程序结构设计","slug":"Python插件式程序结构设计","date":"2018-04-23T06:27:19.000Z","updated":"2019-04-04T10:10:23.686Z","comments":true,"path":"2018/04/23/Python插件式程序结构设计/","link":"","permalink":"http://thinkhard.tech/2018/04/23/Python插件式程序结构设计/","excerpt":"","text":"Python 插件式程序结构设计 小姐姐，你的插件掉了 本文源码在 github/wangshub 最近有个问题一直困扰着我，我经常会遇到\b对以前的程序或者代码进行功能的\b扩充，但是由于前期没有太多程序架构上的设计，导致功能扩充时冗余代码太多，而且不方便维护( YC 创始人 Paul Graham 其实推荐这种做法，产品快速上线，获取用户反馈进行修改)。 知名的插件式设计的项目有 Emacs Vs-code Atom 为了拓展软件的功能，经常会将软件设计成插件式结构，所以就从我熟悉的 Python 开始了解这部分知识。 通过 Google， 发现了 Pluginbase Python 插件框架，可以快速实现一个 Python 插件式结构，这篇博客作为阅读笔记。 项目文件结构 12345678910├── app1│ └── plugins│ └── secret.py├── app2│ └── plugins│ └── randomstr.py├── builtin_plugins│ ├── lowercase.py│ └── uppercase.py└── example.py 插件管理器 获取当前项目的路径\b 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osfrom functools import partialfrom pluginbase import PluginBase# For easier usage calculate the path relative to here.here = os.path.abspath(os.path.dirname(__file__))# 函数包装，重新定义函数签名，减少调用参数get_path = partial(os.path.join, here)print('here:', here)print('get_path:', get_path)# Setup a plugin base for \"example.modules\" and make sure to load# all the default built-in plugins from the builtin_plugins folder.plugin_base = PluginBase(package='example.plugins', searchpath=[get_path('./builtin_plugins')])class Application(object): \"\"\"Represents a simple example application.\"\"\" def __init__(self, name): # Each application has a name self.name = name # And a dictionary where it stores \"formatters\". These will be # functions provided by plugins which format strings. self.formatters = &#123;&#125; # and a source which loads the plugins from the \"&#123;app_name&#125;/plugins\" # folder. We also pass the application name as identifier. This # is optional but by doing this out plugins have consistent # internal module names which allows pickle to work. self.source = plugin_base.make_plugin_source( searchpath=[get_path('./%s/plugins' % name)], identifier=self.name) # Here we list all the plugins the source knows about, load them # and the use the \"setup\" function provided by the plugin to # initialize the plugin. for plugin_name in self.source.list_plugins(): plugin = self.source.load_plugin(plugin_name) plugin.setup(self) def register_formatter(self, name, formatter): \"\"\"A function a plugin can use to register a formatter.\"\"\" self.formatters[name] = formatter \b实现插件 插件 1 ： App1 12345678910111213import stringdef make_secret(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = 'x' return ''.join(chars)def setup(app): app.register_formatter('secret', make_secret) 插件 2 ： App2 1234567891011121314import randomimport stringdef make_random(s): chars = list(s) for idx, char in enumerate(chars): if char not in string.punctuation and not char.isspace(): chars[idx] = random.choice(string.ascii_letters) return ''.join(chars)def setup(app): app.register_formatter('random', make_random) 内置插件 123456def make_lowercase(s): return s.lower()def setup(app): app.register_formatter('lowercase', make_lowercase) \b调用你的插件 1234567def run_demo(app, source): \"\"\"Shows all formatters in demo mode of an application.\"\"\" print('Formatters for %s:' % app.name) print(' input: %s' % source) for name, fmt in sorted(app.formatters.items()): print(' %10s: %s' % (name, fmt(source))) print('') 相关参考\b链接 如何设计插件式结构的程序，兼谈Python语言的动态性 A simple but flexible plugin system for Python. Python Classes PYTHON-进阶-FUNCTOOLS模块小结","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"}]},{"title":"Cerebro插件之电影磁力搜索神器","slug":"Cerebro插件之电影磁力搜索神器","date":"2018-03-31T07:34:51.000Z","updated":"2019-04-04T10:10:23.685Z","comments":true,"path":"2018/03/31/Cerebro插件之电影磁力搜索神器/","link":"","permalink":"http://thinkhard.tech/2018/03/31/Cerebro插件之电影磁力搜索神器/","excerpt":"","text":"Cerebro 插件之电影磁力搜索神器 Cerebro plugin to search torrent of movies 什么？看个片儿还要打开网页慢慢找?！ 这周在学 Node.js, 看了 [@carlos-wong](https://github.com/carlos-wong) 推荐的《Eloquent JavaScript》 这本书的前几章，就抑制不住想写点什么练手。Cerebro 是一个跨平台的快速启动工具（同时支持 Windows、MacOs、Linux），并且可以用 Javascript 定制各种自己喜欢的插件。所以做了一个电影磁力搜索器的插件。 支持平台 Windows、Linux、MacOS 截图 使用 在 Cerebro 对话框中输入电影名称，使用键盘上/下按键选择电影，敲击 回车 ,磁力链接就会自动复制到剪贴板。 magnet [电影名称][空格] 安装步骤 Cerebro 内安装插件 ctrl-space 启动 Cerebro 输入 plugins torrent 点击 install 源码安装 确保安装好了 Cerebro Clone 代码到本地，并执行 123git clone https://github.com/wangshub/cerebro-torrent.gitcd cerebro-torrentyarn install 将 cerebro-torrent 文件夹拷贝或者软链接到 Cerebro 的 node_module 文件夹下； 启动 Cerebro，输入 magnets 葫芦娃，然后敲击 空格； 稍等片刻，上下选择，敲击回车就可以将磁力链接复制到剪贴板； 打开迅雷或者其他下载器，尽情享受吧！ 原理说明 解析输入的指令； 利用 async 和 request 库并发爬取网站； 使用 cheerio 解析网页节点； 嵌入一段 html 对爬取结果进行显示； 代码地址 欢迎 star ⭐️ 和 fork 💫 多提 Issue ! wangshub/cerebro-torrent","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://thinkhard.tech/tags/JavaScript/"}]},{"title":"如何解决EDAS上传论文时fonts问题","slug":"如何解决EDAS上传论文时fonts问题","date":"2018-02-10T09:29:54.000Z","updated":"2019-04-04T10:10:23.771Z","comments":true,"path":"2018/02/10/如何解决EDAS上传论文时fonts问题/","link":"","permalink":"http://thinkhard.tech/2018/02/10/如何解决EDAS上传论文时fonts问题/","excerpt":"","text":"如何解决 EDAS 上传论文时 PDF fonts 问题 问题描述 今天在上传 IEEE xplore 论文时遇到上传字体出错的问题 1upload failed: One or more fonts are not embedded. See EDAS FAQ 解决办法 检查字体子集 在 EDAS 上传 Latex 输出的 PDF 文档时，需要检查 PDF 文档的中所有的字体是否是都是 已嵌入子集，检查方式是： 用 Acrobat pdf或 Foxit PDF工具打开待检查的 PDF 文件 paper.pdf 打开 文件(file)-&gt;属性(property)-&gt;字体(fonts) 查看所有的字体是否是已嵌入或者已嵌入子集 更改字体 如果出现未嵌入的子集 helvitica helvitica字体未嵌入的原因是论文中使用了Matlab生成的图像，Matlab 默认使用了 Helvetica 字体，Latex 在引用该图片时，也默认使用了 Helvetica 字体，导致生成的 PDF 文件不能将这个字体嵌入。 解决步骤： 如果是引用的图片是pdf格式，需要使用 shell 命令ps2pdf13，将Helvetica 进行转化 1ps2pdf13 -dPDFSETTINGS=/prepress fig_non_embedded.pdf fig_embedded.pdf 如果你需要嵌入 *.esp图片文件到你的 Latex 文章中，还需要将步骤1中的 *.pdf 转成 *.esp 文件 1pdftops -eps -level2 [pdfname] [epsname] 参考链接 https://sites.google.com/site/xyzliwen/resource/embed_font_ieee_pdf_explore http://www.mit.edu/~kimo/blog/matlab_figures.html ​","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"http://thinkhard.tech/tags/latex/"}]},{"title":"python装饰器学习笔记","slug":"python装饰器学习笔记","date":"2018-02-07T06:02:39.000Z","updated":"2019-04-04T10:10:23.769Z","comments":true,"path":"2018/02/07/python装饰器学习笔记/","link":"","permalink":"http://thinkhard.tech/2018/02/07/python装饰器学习笔记/","excerpt":"","text":"python 装饰器学习笔记 概括 装饰器的作用就是为已经存在的对象添加额外的功能 我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样就提高了程序的可重复利用性，并增加了程序的可读性。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"}]},{"title":"用python对github用户followers分析","slug":"用python对github用户followers分析","date":"2018-01-15T01:40:16.000Z","updated":"2019-04-04T10:10:23.775Z","comments":true,"path":"2018/01/15/用python对github用户followers分析/","link":"","permalink":"http://thinkhard.tech/2018/01/15/用python对github用户followers分析/","excerpt":"","text":"github 用户 followers 分析 如何分析一个github用户的followers？ 周末手痒，用python分析了一下自己 github 的 followers 用户，统计结果如下 问题分析 在github上，一个用户的主页显示如下，主要对如下用户信息进行提取 - 用户名称 - 所在的位置 - 用户仓库、stars、Followers、Following数量 - 去年一年的贡献度 我们需要对上图红框里面的数据进行提取，最直接的方法是使用requests，通过BeautifulSoup对html中的信息进行提取。 一些弯路 最开始没打算用爬虫的方式来获取用户信息，因为github有公开的REST API v3可以对指定用户的信息进行访问，并且已经有打包好的PyGithub方便调用。但是我实验下来有如下问题所以放弃使用REST API v3 1. API请求频率有限制，无法运用多线程快速获取批量的用户信息 2. 不知道是不是小BUG，通过API无法获得用户去年一年的贡献度contributions 工具 python 3 ： 彻底告别我的py2 BeaufulSoup ：从HTML或XML文件中提取数据 Requests ： 请求网页 多进程 ： 为了更快 pyecharts ： 美的令人窒息的绘图工具 操作步骤 获取目标用户如https://github.com/wangshub?page=1&amp;tab=followers的所有followers； 改变page编号，遍历所有用户； 提取用户关键信息，保存成csv文件； 数据清洗，过滤； 利用pyecharts绘图； 进行地点词频统计； 实验结果 截止2018-01-15,我的github账号一共有1214名follower，分析结果如下 用户地点分析 排除掉没有填写地点信息的用户，将中文转化成pinyin后，词云如下 用户基本上都是来自北京、上海、深圳等地 去年一年用户贡献度分析 如果看用户是否活跃，肯定是看contributions啦 可以看出超过一般多的用户，去年的贡献度都在都在 1~50 之间，新的一年要加油啦。其中一年贡献最多的用户是[@dragon-yuan](https://github.com/dragon-yuan), 在2017年有整整 4,197 个贡献度，不多说了，前去关注一波。 用户followers分析 哇，有大牛，别拦着我，我要去点关注了 用户仓库数量分析 通过爬取用户的仓库数量，进行统计如下 可以看到一个有意思的现象，有少数的人仓库数量超过了1000，打开这几位仁兄的github主页，大部分是fork的项目，其中仓库最多的用户有13100个仓库，叫[@ProgrammerAndHacker](https://github.com/ProgrammerAndHacker)，他是这么介绍自己的 1234I follow best programmer and hacker， Do you want to hacked by them? ^_^ Best programmers and hackers are here: ... 用户stars分析 都说点击star是一个好习惯， 不得不说，github上面还是有点赞狂魔的，这位老铁[@chenruibin](https://github.com/chenruibin)一共点击了10100个赞，真是好习惯～ 用户 following 分析 同样是[@ProgrammerAndHacker](https://github.com/ProgrammerAndHacker)这位仁兄，一共follow了19600个用户，严重怀疑是不是机器人。 最后 不搞了，我要去写论文了TAT，要代码的，来这里找https://github.com/wangshub/who_is_following","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"},{"name":"github","slug":"github","permalink":"http://thinkhard.tech/tags/github/"}]},{"title":"教你用Python来玩微信跳一跳","slug":"教你用Python来玩微信跳一跳","date":"2017-12-29T02:02:41.000Z","updated":"2019-04-04T10:10:23.773Z","comments":true,"path":"2017/12/29/教你用Python来玩微信跳一跳/","link":"","permalink":"http://thinkhard.tech/2017/12/29/教你用Python来玩微信跳一跳/","excerpt":"","text":"教你用Python来玩微信跳一跳 2017年12月28日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 demo「跳一跳」。 blog 地址 github 地址 知乎专栏 游戏模式 这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。 玩法类似于《flappy bird》 如果能精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃？所以花2个小时写了一个python脚本进行验证 工具介绍 Python 2.7 Android 手机 Adb 驱动 Python Matplot绘图 原理说明 将手机点击到《跳一跳》小程序界面； 用Adb 工具获取当前手机截图，并用adb将截图pull上来 12adb shell screencap -p /sdcard/1.pngadb pull /sdcard/1.png . 用matplot显示截图； 用鼠标点击起始点和目标位置，计算像素距离； 根据像素距离，计算按压时间； 用Adb工具点击屏幕蓄力一跳； 1adb shell input swipe x y x y time 实验结果 TODO 可以对拉上来的图片进行颜色分割，识别小人和目标中心店，这样就不需要手动点击自动弹跳。 事实证明，机器人比人更会玩儿游戏。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"}]},{"title":"Python蔡英文facebook主页分析_by神奇的战士","slug":"Python蔡英文facebook主页分析-by神奇的战士","date":"2017-12-25T07:14:39.000Z","updated":"2019-04-04T10:10:23.686Z","comments":true,"path":"2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","link":"","permalink":"http://thinkhard.tech/2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/","excerpt":"","text":"Python蔡英文facebook主页分析(by神奇的战士) 博客地址：https://wangshub.github.io/ 公众号：神奇的战士 拒绝转载 用Facebook Graph API和情绪分析API对蔡英文Facebook主页进行统计分析。 1. 说明 蔡英文2016年5月20日，蔡英文正式就任台湾地区领导人，成为台湾地区首位女性领导人。 最近台湾省地区新闻主要有： &gt; 新闻来源： 人民网 &gt; 坚决惩治电信诈骗犯罪 切实维护两岸同胞利益 &gt; 两岸学者评新党人士被调查事件：民进党当局逆流而动终将自掘坟墓 &gt; 台民众高呼“醒来”，蔡英文不能继续装睡 &gt; ... 但是真实的台湾同胞们是如何看待她的执政表现呢？ 2. 实现工具 如果是直接爬取脸书的主页，需要进行模拟登陆，反爬虫，代理，验证等等一系列的操作。幸好脸书开放出了图API，可以在一定的请求限制下对脸书上的数据进行访问。注意在多线程请求API的时候，不应该请求的太快，否则会被系统封禁一段时间(不要问我为什么-_-)。 目前为止使用了如下这些工具： python 2.7 Facebook Graph API 情感分析API python 词云 python 中文jieba分词 python Pandas python 多线程 3. 数据处理 3.1 posts 首先测试脸书Facebook Graph API，对蔡小姐的post进行访问， curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/tsaiingwen/posts?access_token=xxxxxxxxxxxxxxxxx\" 返回示例 1234567891011121314151617\"data\": [ &#123; \"created_time\": \"2017-12-24T11:50:06+0000\", \"message\": \"蔡想想🐱祝福大家聖誕快樂🎅 #MerryChristmas\", \"id\": \"46251501064_10154820163381065\" &#125;, ... ...],\"paging\": &#123; \"cursors\": &#123; \"before\": \"xxxxxx\", \"after\": \"xxxxx\" &#125;, \"next\": \"xxxxxxxxxxxxxxxxxxxxxx\" &#125; 可以观察到，脸书的每一个post都对应了一个唯一的id，由于post的数量是在太多，所以一次请求无法完整获取。根据next可以得到下一页的post，直到next为空时，表示所有的post获取完毕。 根据以上原理，我获取了蔡小姐从开通脸书第一天起到今天，发的每一条post。 横坐标：时间 纵坐标：每天发文数量 自 2008-10-22T13:55:20+0000蔡小姐发了第一条post以来，一共发了4120篇状态，基本上在脸书上还是非常活跃的，在2012年最多一天发送了24条状态，成功刷屏。 3.2 comments 与 3.1节类似，每一个post下都会有网友进行评论，那么如何获取所有评论?参考图谱API文档，利用测试脚本 curl测试脚本 12curl -i -X GET \\ \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxxxxxx\" 返回示例 12345678910111213141516&#123; \"data\": [ &#123; \"created_time\": \"2017-11-13T07:15:25+0000\", \"message\": \"XXXXXXXX\", \"id\": \"10154729068451065_10154729097936065\" &#125;, ... ... \"paging\": &#123; \"cursors\": &#123; \"before\": \"MTQyNQZDZD\", \"after\": \"MTM5MQZDZD\" &#125;, \"next\": \"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxx&amp;pretty=0&amp;limit=25&amp;after=MTM5MQZDZD\" &#125; 每一条评论都对应着唯一的id，next字段是下一页的评论内容。可以通过设置，选择一夜最多显示100条评论。以此逐级获取所有的评论。 横坐标：时间 纵坐标：每条状态对应的评论数量 一共爬取了1830322条网友评论，最多评论数是23630条。其中几次出现了较大值，原因应该是前几次大陆网友自发组织的Facebook远征军去进行友好访问了。具体内容可以接下来对这几次的峰值进行详细分析。 相关新闻： 帝吧“远征”facebook｜一场表情包大战的爱国交流 如何评价李毅吧 2016 年 1 月 20 日「出征」Facebook？ 4. 数据分析 4.1. 蔡英文主页分析 一共获取了蔡小姐的4120状态，对json的message字段进行提取，将所有的状态的文字保存进行词云分析，看哪些词汇出现的频率最高。 首先利用Pandas对状态的结构数据进行保存； 读取Pandas表格，获取所有的状态文字； 利用jieba中文分词库，对所有的文字进行分割； 显示，保存图片； 蔡小姐词云 4.2. 蔡英文评论分析 从蔡小姐的post的所有评论当中，我找出了一条评论最多的状态，共有23630条评论，对应id为46251501064_10154244975341065，读取对应数据文件，利用词云分析可得 看来台湾网友也十分注意安全开车，其实这条post的评论区被台湾网友刷屏了，看来怨气挺重呢，哈哈哈哈，霸屏具体内容是 12345671.政府請正視目前台灣改裝汽機車問題！排氣管及改裝品可以合法製造 合法販賣 合法進口但裝載車上就不合法 這是什麼邏輯 政府要課稅又要開罰單又是什麼想法？排氣管或車上零件是原廠被惡意檢舉驗車那是否能跟監理單位或環保署拿今日上班請假損失？2.環保局 監理站 警察執法單位 專業度嚴重不足 原廠排氣管也開單 叫民眾到監理單位驗車 當做民眾都很有時間？3.請提供可比照國外變更車體，如重機行李箱、遮陽板、避震、制動煞車系統在不影響行車安全的部份合乎法規4.如民眾遭受到檢舉達人惡意檢舉，因此需要請假驗車，若屬於惡意檢舉，政府需要支付民眾請假之當天工資蔡??...您不是希望台灣能跟世界接軌，那請您重視汽機車改裝合法性與可變更性，在不影響行車安全與噪音的&gt; 情況下，請把檢舉改裝還於司法單位執行，才不構成擾民。 既然这条被刷屏了，那就换成最新的一篇post，看看网友又关心啥问题。。。 截止爬取脸书时，最新一条博客是： 12345你有吃過越南生春捲、香蘭娘惹糕或是薑黃飯嗎？它們是來自東南亞各國的美食，現在也是台灣的美食。今天是國際移民日，前幾天，我邀請了幾位新移民的好朋友來到總統府，一起準備午餐。在這場午餐的約會中，他們和我分享來到台灣生活的點點滴滴，也給我很多建議。謝謝你們來到台灣，讓我們的社會更多元、更茁壯。祝大家國際移民日快樂！#留言告訴我你最喜歡的新南向美食#晚餐文&quot;, 蔡小姐问网友喜欢吃啥美食，我们来看看网友是如何回复的 结合最近的新党王炳忠事件，评论中出现了较多绿色恐怖、王炳忠、白色恐怖等高频词汇 5. TODO 可以分析的数据还有很多，就先分析这么多了，接下来，可以对评论进行情感分析，看下网友对蔡小姐的评论是积极还是消极的多一些。不过经过这一年的时间来看，应该是消极多一点。哈哈哈 总结下来，我认为： 台湾社会的认知是处于一个分裂的状态； 不少年轻人还是无脑反对大陆； 真正理性思考人太少； 不少人处于岛内的小确幸当中； 结合最近的新闻来看，猜测台湾的士兵在开战时会不会遇到为了什么而战斗的信仰问题。哈哈，一百分将军太逗啦","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"}]},{"title":"linux驱动器和分区的备份，使用dd命令示例","slug":"linux驱动器和分区的备份，使用dd命令示例","date":"2017-12-18T12:04:51.000Z","updated":"2019-04-04T10:10:23.692Z","comments":true,"path":"2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","link":"","permalink":"http://thinkhard.tech/2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","excerpt":"","text":"dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，下面这篇文章将帮助你学习一些有用的“dd”命令。 ## 1：创建现有分区备份 以下命令将整个分区/dev/sdb1备份到/opt/sdb1.img文件。 # dd if=/dev/sdb1 of=/opt/sdb1.img 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 123.319 s, 66.7 MB/s 2：恢复备份到其他分区 上面 /opt/sdb1.img备份文件可以恢复到其他分区（/dev/sdb2），我们可以用以下命令恢复。 # dd if=/opt/sdb1.img of=/dev/sdb2 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 197.688 s, 41.6 MB/s 现在，你可以看到的/dev/sdb2 是/dev/sdb1 的翻版。 ## 3：创建与现有分区副本 我们可以直接从现有的分区副本来分区。以下命令将创建的/dev/sdb1 到 /dev/sdb2 的副本。 # dd if=/dev/sdb1 of=/dev/sdb2 样本输出 12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 221.431 s, 37.1 MB/s 4：创建现有的硬盘克隆 以下命令将复制前446个字节这是MBR从第一个磁盘到第二个磁盘。这将创建第二个磁盘引导。 。 # dd if=/dev/sda of=/dev/sdb bs=446 count=1 1231+0 records in1+0 records out446 bytes (446 B) copied, 0.00174812 s, 255 kB/s 现在确保在/dev/sdb的匹配为/dev/sda的分区。一旦做到这一点，您可以使用复制每个分区： # dd if=/dev/sda1 of=/dev/sdb1 # dd if=/dev/sda2 of=/dev/sdb2 5：备份和恢复的MBR镜像文件 创建使用以下命令MBR的镜像文件的备份。 # dd if=/dev/sda of=/opt/backup-mbr-sda.img bs=512 count=1 示例输出 1231+0 records in1+0 records out512 bytes (512 B) copied, 0.0115243 s, 44.4 kB/s 接下来的步骤是MBR恢复到不同的磁盘，使用下面的命令来做到这一点。 # dd if=/opt/backup-mbr-sda.img of=/dev/sdb bs=446 count=1","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://thinkhard.tech/tags/linux/"}]},{"title":"python数字图像处理-图像噪声与去噪算法","slug":"python数字图像处理-图像噪声与去噪算法","date":"2017-12-16T09:19:29.000Z","updated":"2019-04-04T10:10:23.768Z","comments":true,"path":"2017/12/16/python数字图像处理-图像噪声与去噪算法/","link":"","permalink":"http://thinkhard.tech/2017/12/16/python数字图像处理-图像噪声与去噪算法/","excerpt":"","text":"python数字图像处理-图像噪声与去噪算法 figure_1.png 图像噪声 椒盐噪声 概述： 椒盐噪声（salt &amp; pepper noise）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，产生该噪声的算法也比较简单。 给一副数字图像加上椒盐噪声的步骤如下： 指定信噪比 SNR （其取值范围在[0, 1]之间） 计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR) 随机获取要加噪的每个像素位置P（i, j） 指定像素值为255或者0。 重复3,4两个步骤完成所有像素的NP个像素 输出加噪以后的图像 高斯噪声 概述： 加性高斯白噪声(Additive white Gaussian noise，AWGN)在通信领域中指的是一种功率谱函数是常数(即白噪声), 且幅度服从高斯分布的噪声信号. 这类噪声通常来自感光元件, 且无法避免. 去噪算法 中值滤波 概述： 中值滤波是一种非线性空间滤波器, 它的响应基于图像滤波器包围的图像区域中像素的统计排序, 然后由统计排序结果的值代替中心像素的值. 中值滤波器将其像素邻域内的灰度中值代替代替该像素的值. 中值滤波器的使用非常普遍, 这是因为对于一定类型的随机噪声, 它提供了一种优秀的去噪能力, 比小尺寸的均值滤波器模糊程度明显要低. 中值滤波器对处理脉冲噪声(也称椒盐噪声)非常有效, 因为该噪声是以黑白点叠加在图像上面的. 与中值滤波相似的还有最大值滤波器和最小值滤波器. 均值滤波 概述： 均值滤波器的输出是包含在滤波掩模领域内像素的简单平均值. 均值滤波器最常用的目的就是减噪. 然而, 图像边缘也是由图像灰度尖锐变化带来的特性, 所以均值滤波还是存在不希望的边缘模糊负面效应. 均值滤波还有一个重要应用, 为了对感兴趣的图像得出一个粗略描述而模糊一幅图像. 这样, 那些较小物体的强度与背景揉合在一起了, 较大物体变得像斑点而易于检测.掩模的大小由即将融入背景中的物体尺寸决定. 代码 见https://github.com/wangshub/python-image-process","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://thinkhard.tech/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://thinkhard.tech/tags/image/"}]},{"title":"python数字图像处理-图像的基本结构和基础知识","slug":"python数字图像处理-图像的基本结构和基础知识","date":"2017-12-16T09:10:39.000Z","updated":"2019-04-04T10:10:23.768Z","comments":true,"path":"2017/12/16/python数字图像处理-图像的基本结构和基础知识/","link":"","permalink":"http://thinkhard.tech/2017/12/16/python数字图像处理-图像的基本结构和基础知识/","excerpt":"","text":"数字图像处理-图像的基本结构和基础知识 LenaRGB.bmp 一、python实现BMP图像的读取和显示 BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。 BMP文件的数据按照从文件头开始的先后顺序分为四个部分： bmp文件头(bmp file header) ：提供文件的格式、大小等信息 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 位图数据(bitmap data)：就是图像数据 参考链接 https://zh.wikipedia.org/wiki/BMP 二、python统计图像的直方图 图像直方图（英语：Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布。这种直方图中，横坐标的左侧为纯黑、较暗的区域，而右侧为较亮、纯白的区域。因此，一张较暗图片的图像直方图中的数据多集中于左侧和中间部分；而整体明亮、只有少量阴影的图像则相反。 很多数码相机提供图像直方图功能，拍摄者可以通过观察图像直方图了解到当前图像是否过分曝光或者曝光不足。 计算机视觉领域常借助图像直方图来实现图像的二值化 2 统计直方图.png 参考链接 https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE 三、RGB、YIQ、HSI、XYZ颜色空间 YIQ YIQ色彩空间通常被北美的电视系统所采用，属于NTSC（National Television Standards Committee）系统。这里Y不是指黄色，而是指颜色的明视度（Luminance），即亮度（Brightness）。其实Y就是图像的灰度值（Gray value），而I和Q则是指色调（Chrominance），即描述图像色彩及饱和度的属性。在YIQ系统中，Y分量代表图像的亮度信息，I、Q两个分量则携带颜色信息，I分量代表从橙色到青色的颜色变化，而Q分量则代表从紫色到黄绿色的颜色变化。 NTSC制为了进一步压缩色度带宽，用色差信号I,Q来代替U,V。若采用U,V色差信号，则色度、亮度信号的共频带部分极大，低端不共频带的亮度信号带宽很小，亮、色干扰大。将彩色图像从RGB转换到YIQ色彩空间，可以把彩色图像中的亮度信息与色度信息分开，分别独立进行处理。 RGB和YIQ的对应关系用下面的方程式表示： 123Y=0.299R+0.587G+0.114BI=0.596R-0.274G-0.322BQ=0.211R-0.523G+0.312B 3 YIQ分量.png HSI 色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。 饱和度S（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。 亮度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度。 若将RGB单位立方体沿主对角线进行投影，可得到六边形，这样，原来沿主对角线的灰色都投影到中心白色点，而红色点（1，0，0）则位于右边的角上，绿色点（0，1，0）位于左上角，蓝色点（0，0，1）则位于左下角。 HSI颜色模型的双六棱锥表示，I是强度轴，色调H的角度范围为[0，2π]，其中，纯红色的角度为0，纯绿色的角度为2π/3，纯蓝色的角度为4π/3。饱和度S是颜色空间任一点距I轴的距离。当然，若用圆表示RGB模型的投影，则HSI色度空间为双圆锥3D表示。 注意： 当强度I=0时，色调H、饱和度S无定义；当S=0时，色调H无定义。 HSI模型也可用圆柱来表示，如图9-5所示。若将其展开，并按图9-6进行定义，可得到HSI调色板。 HSI_Formula.jpg 5 HSI分量.png XYZ 国际照明委员会(CIE)在进行了大量正常人视觉测量和统计,1931年建立了\"标准色度观察者\"， 从而奠定了现代CIE标准色度学的定量基础。由于\"标准色度观察者\"用来标定光谱色时出现负 刺激值，计算不便，也不易理解，因此1931年CIE在RGB系统基础上，改用三个假想的原色X、Y、 Z建立了一个新的色度系统。将它匹配等能光谱的三刺激值，定名为\"CIE1931 标准色度观察者 光谱三刺激值\"，简称为\"CIE1931标准色度观察者\"。这一系统叫做\"CIE1931标准色度系统\"或称为\" 2° 视场XYZ色度系统\"。CIEXYZ颜色空间稍加变换就可得到Yxy色彩空间，其中Y取三刺激值中Y的值， 表示亮度，x、y反映颜色的色度特性。定义如下：在色彩管理中，选择与设备无关的颜色空间是 十分重要的，与设备无关的颜色空间由国际照明委员会(CIE)制定，包括CIEXYZ和CIELAB两个标准。 它们包含了人眼所能辨别的全部颜色。而且，CIEYxy测色制的建立给定量的确定颜色创造了条件。 但是，在这一空间中，两种不同颜色之间的距离值并不能正确地反映人们色彩感觉差别的大小， 也就是说在CIEYxy色厦图中，在 不同的位置不同方向上颜色的宽容量是不同的，这就是Yxy颜色空间 的不均匀性。这一缺陷的存在，使得在Yxy及XYZ空间不能直观地评价颜色。 xyz.jpg 6 XYZ分量.png 四、python代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#encoding: utf-8import numpy as npfrom PIL import Imageimport matplotlib.pyplot as pltimport mathdef show_bmp(img): # BMP 的读取与显示 plt.figure(\"LenaRGB.bmp\") plt.title(\"LenaRGB.bmp\") plt.imshow(img) plt.show()def show_hist(img): # 直方图 plt.figure(\"Lena hist\") plt.title('Lena hist figure') arr = img.flatten() n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75) plt.show()def show_rgb(img): # 显示RGB图像 plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('R') plt.imshow(img[:, :, 0], cmap='gray') plt.subplot(223) plt.title('G') plt.imshow(img[:, :, 1], cmap='gray') plt.subplot(224) plt.title('B') plt.imshow(img[:, :, 2], cmap='gray') plt.show()def shou_yiq(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) Y = 0.299 * R + 0.587 * G + 0.114 * B I = 0.596 * R - 0.274 * G - 0.322 * B Q = 0.211 * R - 0.523 * G - 0.312 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(223) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(224) plt.title('Q') plt.imshow(Q, cmap='gray') plt.show() # YIQ = def show_xyz(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) X = 0.490 * R + 0.310 * G + 0.200 * B Y = 0.177 * R + 0.813 * G + 0.011 * B Z = 0.000 * R + 0.010 * G + 0.990 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('X') plt.imshow(X, cmap='gray') plt.subplot(223) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(224) plt.title('Z') plt.imshow(Z, cmap='gray') plt.show()def show_hsi(img): rows, cols, dims = img.shape R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) I = (R + G + B) / 3 E = np.mat(np.ones([rows, cols])) minRGB = np.mat(img.min(2)) lv = 3 * E / (R + G + B) S = E - np.multiply(lv, minRGB) # S = np.mat(np.zeros([rows, cols])) # for i in range(rows): # for j in range(cols): # S[i, j] = 1 - 3/(R[i, j] + G[i, j] + B[i, j]) * min([R[i, j], G[i, j], B[i, j]]) H = np.mat(np.zeros([rows, cols])) for i in range(rows): for j in range(cols): up = (R[i, j] - G[i, j] + R[i, j] - B[i, j]) / 2 down = (R[i, j] - G[i, j])**2 + (R[i, j] - B[i, j]) * (G[i, j] - B[i, j])**0.5 H[i, j] = math.acos(up / down) plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(223) plt.title('S') plt.imshow(S, cmap='gray') plt.subplot(224) plt.title('H') plt.imshow(H, cmap='gray') plt.show()def main(): img = np.array(Image.open('/home/sun/Desktop/PycharmProjects/Digital_image_process_lxk/lab1/LenaRGB.bmp')) rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # show_bmp(img) # show_hist(img) # show_rgb(img) # shou_yiq(img) # show_hsi(img) # show_xyz(img)if __name__ == '__main__': main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://thinkhard.tech/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://thinkhard.tech/tags/image/"}]},{"title":"python：将图片转换成excel文档","slug":"image-to-excel","date":"2017-12-14T13:28:12.000Z","updated":"2019-04-04T10:10:23.692Z","comments":true,"path":"2017/12/14/image-to-excel/","link":"","permalink":"http://thinkhard.tech/2017/12/14/image-to-excel/","excerpt":"","text":"python：将图片转换成excel文档 实现步骤 读取图像，获取图像每个像素点的RGB值； 根据每个像素点的RGB值设置excel每个方格的颜色值； 根据像素点的坐标，写入excel文件； 保存退出； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npimport timeimport matplotlib.pyplot as pltimport xlsxwriterdef get_xy(row, col): table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' num1 = col / 26 num2 = col % 26 # print num1, num2 if num1 == 0: return table[num2 - 1] + str(row) else: return table[num1-1] + table[num2 - 1] + str(row)def main(): img = np.array(Image.open('whale.jpeg')) # plt.figure(\"whale\") # plt.imshow(img) # plt.show() rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # print img[188, 188, 0] excel = xlsxwriter.Workbook('image_excel.xlsx') cellformat = excel.add_format(&#123;'bg_color': '#123456', 'font_color': '#654321'&#125;) worksheet1 = excel.add_worksheet() data = [] color = [''] * cols cellcolor = \"\" for i in range(rows): for j in range(cols): # print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2]) cellcolor = (hex(img[i, j, 0]) + hex(img[i, j, 1]) + hex(img[i, j, 2])).replace('0x', '') # print cellcolor cellformat = excel.add_format(&#123;'bg_color': '#'+cellcolor, 'font_color': '#'+cellcolor&#125;) # cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', # 'font_color': '#006100'&#125;) worksheet1.conditional_format(get_xy(i, j), &#123;'type': 'cell', 'criteria': '&lt;', 'value': 50, 'format': cellformat&#125;) # data.append(data_row) excel.close() if __name__ == '__main__': main() # print get_xy(133, 27)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"}]},{"title":"python check hosts update","slug":"python-check-hosts-update","date":"2017-07-20T14:33:15.000Z","updated":"2019-04-04T10:10:23.766Z","comments":true,"path":"2017/07/20/python-check-hosts-update/","link":"","permalink":"http://thinkhard.tech/2017/07/20/python-check-hosts-update/","excerpt":"","text":"用Python检查 hosts 更新 最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。 hosts地址 hosts_info.py 1hosts_source = [\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\"] 检查hosts是否有更新 check_hosts.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib2from .hosts_info import *import osimport filecmpdef hosts_download(): if os.path.exists('hosts'): hosts_name = 'hosts_new' else: hosts_name = 'hosts' # todo: overtime detection f = urllib2.urlopen(hosts_source[0]) print \"downloading hosts\" with open(hosts_name, \"wb\") as code: code.write(f.read())def is_hosts_new(): hosts_download() if not os.path.exists('hosts'): print 'oops, hosts not exists' return -1 elif os.path.exists('hosts') and (not os.path.exists('hosts_new')): print 'first run, only one hosts file' return True elif os.path.exists('hosts') and (os.path.exists('hosts_new')): print 'compare hosts &amp; hosts_new' diff_status = filecmp.cmp('hosts', 'hosts_new') if diff_status: print 'same file' os.remove('hosts_new') return False else: print 'diff file' os.remove('hosts') os.rename('hosts_new', \"hosts\") return True else: return -1 主程序调用 main.py 1234567from check_hosts.check_hosts import *diff_status = is_hosts_new()if diff_status: print \"new hosts !\"else: print 'code: ',diff_status","categories":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/categories/Python/"},{"name":"VPN","slug":"Python/VPN","permalink":"http://thinkhard.tech/categories/Python/VPN/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"VPN","slug":"VPN","permalink":"http://thinkhard.tech/tags/VPN/"}]},{"title":"python mail sender","slug":"python-mail-sender","date":"2017-07-20T14:22:06.000Z","updated":"2019-04-04T10:10:23.767Z","comments":true,"path":"2017/07/20/python-mail-sender/","link":"","permalink":"http://thinkhard.tech/2017/07/20/python-mail-sender/","excerpt":"","text":"python 发送邮件 配置服务器和邮箱 mail_info.py 123456mail_host = 'smtp.yeah.net'mail_user = 'mail_name'mail_pass = 'mail_password'sender = 'mail_name@yeah.net'receivers = ['target@mail.com'] 发送邮件 mail_trans.py 1234567891011121314151617181920212223from .mail_info import *import smtplibfrom email.mime.text import MIMETextdef mail_text_send(title, text): message = MIMEText(text, 'plain', 'utf-8') message['Subject'] = title message['From'] = sender message['To'] = receivers[0] try: smtpObj = smtplib.SMTP() # connect host smtpObj.connect(mail_host, 25) # login host smtpObj.login(mail_user, mail_pass) # send smtpObj.sendmail(sender, receivers, message.as_string()) # quit smtpObj.quit() return True except smtplib.SMTPException as e: return False 主程序调用 main.py 12from mail_trans import *mail_text_send('title', 'hello world!')","categories":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://thinkhard.tech/categories/Python/Code/"},{"name":"Mail","slug":"Python/Code/Mail","permalink":"http://thinkhard.tech/categories/Python/Code/Mail/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://thinkhard.tech/tags/Code/"},{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/tags/Python/"},{"name":"Mail","slug":"Mail","permalink":"http://thinkhard.tech/tags/Mail/"}]},{"title":"使用python备份博客图床图片","slug":"use-python-to-backup-markdown-images","date":"2017-06-05T15:09:29.000Z","updated":"2019-04-04T10:10:23.770Z","comments":true,"path":"2017/06/05/use-python-to-backup-markdown-images/","link":"","permalink":"http://thinkhard.tech/2017/06/05/use-python-to-backup-markdown-images/","excerpt":"","text":"# 说明 最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误. 所以花了一点时间,用python 正则匹配 markdown中图片链接,然后下载图片保存到本地文件夹img中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~ 功能 .md文件自动搜索 正则匹配图片链接 爬取图片内容 保存文本到本地 步骤 读取文件 =&gt; 正则匹配 =&gt; 图片下载 =&gt; 保存本地 python代码 详细见我的github地址: www.github.com/wangshub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding=utf-8import sysimport osimport reimport requestsimport urllibimport urllib2def search(path, word): for filename in os.listdir(path): fp = os.path.join(path, filename) if os.path.isfile(fp) and word in filename: print fp download(str(fp)) elif os.path.isdir(fp): search(fp, word)def download(file_path): # filename = \"test\" name = file_path.split(u\"/\") filename = name[-1] f_md = open(file_path) # all text of md file text = f_md.read().decode('utf-8') # regex img_reg = r'\\!&#123;1&#125;\\[(.*?)\\]\\((.*?)\\)' result = re.findall('!\\[(.*)\\]\\((.*)\\)', text) for i in range(len(result)): img_quote = result[i][0] img_url = result[i][1] # download img request = urllib2.Request(img_url) response = urllib2.urlopen(request) img_contents = response.read() # img name spell urlname = img_url.split(u\"/\") img_name = filename + '_' + \\ str(i) + '_' + img_quote + str(urlname[len(urlname) - 1]) print img_name, '~~~', img_url # write to file f_img = open('img/' + img_name, 'wb') f_img.write(img_contents) f_img.close() f_md.close()search(sys.argv[1], '.md') 食用方法 python md_image_bacup.py /path/to/your/file/ 作者 Author : WangSong E-mail : easternslope@yeah.net","categories":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/categories/python/"},{"name":"markdown","slug":"python/markdown","permalink":"http://thinkhard.tech/categories/python/markdown/"},{"name":"code","slug":"python/markdown/code","permalink":"http://thinkhard.tech/categories/python/markdown/code/"}],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"},{"name":"code","slug":"code","permalink":"http://thinkhard.tech/tags/code/"},{"name":"markdown","slug":"markdown","permalink":"http://thinkhard.tech/tags/markdown/"}]},{"title":"从机sshfs访问主机文件系统","slug":"sshfs-mount-net-disk","date":"2017-05-31T13:16:00.000Z","updated":"2019-04-04T10:10:23.769Z","comments":true,"path":"2017/05/31/sshfs-mount-net-disk/","link":"","permalink":"http://thinkhard.tech/2017/05/31/sshfs-mount-net-disk/","excerpt":"","text":"# 说明 需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到scp命令 scp -r /主机/文件 从机名@192.168.x.x:从机目录/.利用sshfs可以直接在从机进行编译,省略拷贝步骤. 系统结构框图 Linux 主机 &lt;=====&gt; Linux 从机 操作步骤 主机 sudo apt-get install openssh-server ifconfig -a获取局域网内 IP地址 从机 sudo apt-get install sshfs sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace 现在可以从从机开心地访问主机文件了 author : Wangsong mail : easternslope@yeah.net","categories":[{"name":"linux","slug":"linux","permalink":"http://thinkhard.tech/categories/linux/"},{"name":"tool","slug":"linux/tool","permalink":"http://thinkhard.tech/categories/linux/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://thinkhard.tech/tags/linux/"},{"name":"tool","slug":"tool","permalink":"http://thinkhard.tech/tags/tool/"}]},{"title":"python 数据结构之二叉搜索树","slug":"python-data-structure-BST","date":"2017-05-29T15:06:12.000Z","updated":"2019-04-04T10:10:23.767Z","comments":true,"path":"2017/05/29/python-data-structure-BST/","link":"","permalink":"http://thinkhard.tech/2017/05/29/python-data-structure-BST/","excerpt":"","text":"二叉搜索树定义 一颗二叉搜索树是以二叉树来组织的,每个节点除了 Key 还包括 左孩子, 右孩子, 父节点 等信息. BST满足限制条件: 对于任意节点的X,他的 左子树中关键字最大值&lt;=X.key , 右子树关键字最小值&gt;=X.key 这个关系表示如下 二叉 根据上图定义,一个二叉搜索树的例子是 二叉树操作 查询 插入 删除 查询(搜索) 二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下 可以写成 伪代码 1234567TREE-SEARCH(x, k) if x == NULL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left) if k &gt; x.key return TREE-SEARCH(x.right) 转换成python代码 12345678910111213141516171819def _get(self, key, node): if node is None: return None if key &lt; node.key: return self._get(key, node.left) elif key &gt; node.key: return self._get(key, node.right) else: return node.valdef get(self, key): \"\"\" Return the value paired with 'key' Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" return self._get(key, self.root) 插入 插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部 查询插入节点 改变目标节点附近的数据结构 插入过程示意图如下 相应的伪代码如下, 输入节点 z , z.key = v, z.left = NULL, z.right = NULL. 12345678910111213141516TREE-INSERT(T, x) y = NULL x = T.root # 从根节点开始 while x != NULL y = x # 保存上一节点 if z.key &lt; x.key # 往左 x = x.left else # 往右 x = x.right z.p = y # 父节点 if y == NULL # tree T 为空 T.root = z else if z.key &lt; y.key y.left = z else y.right = z 程序的运行复杂度取决于二叉树的形状 插入的运行时间取决于二叉搜索树的_高度h_,程序的运行时间_O(h)_ ,所以二叉树形状的好坏直接影响算法的运行时间. python代码实现为 123456789101112131415161718192021222324252627def _put(self, key, val, node): # If we hit the end of a branch, create a new node if node is None: return Node(key, val) # Follow left branch if key &lt; node.key: node.left = self._put(key, val, node.left) # Follow right branch elif key &gt; node.key: node.right = self._put(key, val, node.right) # Overwrite value else: node.val = val node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef put(self, key, val): \"\"\" Add a new key-value pair. Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" self.root = self._put(key, val, self.root) 删除 删除总共分为三种情况: 如果删除节点x没有孩子,直接删除即可; 如果删除节点x有1个孩子,用孩子替换该节点位置; 如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 x的继承者 . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤: 输入待删除的节点x 和 二叉搜索树T. 在节点x的右子树开始搜索:往右再往左找到最小值节点H; H右孩子为H的父节点, H的左孩子为X的左孩子; 示意图如下,应该一目了然: ](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![ 根据上面的描述,删除的伪代码可以分为两部分: 为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点. 123456789TRANSPLANT(T, u, v)if u.p == NULLT.root = velse if u = u.p.leftu.p.left = velse u.p.right = vif v!= NULLv.p = u.p 根据第一步完成二叉搜索树的删除过程: 1234567891011121314TREE-DELETE(T, z)if z.left = NULLTRANSPLANT(T, z, z.right)else if (z.right == NULL)TRANSPLANT(T, z, z.left)elsey = TREE-MINIMUM(z.right)if y.p != zTRANSPLANT(T, y, y.right)y.right = z.righty.right.p = yTRANSPLANT(T, z, y)y.left = z.lefty.left.p = y 用python 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _delete(self, key, node): if node is None: return None if key &lt; node.key: node.left = self._delete(key, node.left) elif key &gt; node.key: node.right = self._delete(key, node.right) else: if node.right is None: return node.left elif node.left is None: return node.right else: old_node = node node = self._ceiling_node(key, node.right) node.right = self._delete_min(old_node.right) node.left = old_node.left node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _delete_min(self, node): if node.left is None: return node.right node.left = self._delete_min(node.left) node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _ceiling_node(self, key, node): \"\"\" Returns the node with the smallest key that is greater than or equal to the given value 'key' \"\"\" if node is None: return None if key &lt; node.key: # Ceiling is either in left subtree or is this node attempt_in_left = self._ceiling_node(key, node.left) if attempt_in_left is None: return node else: return attempt_in_left elif key &gt; node.key: # Ceiling must be in right subtree return self._ceiling_node(key, node.right) else: # Keys are equal so ceiling is node with this key return node 参考文献 &lt;&gt; http://algs4.cs.princeton.edu/32bst/","categories":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/categories/python/"},{"name":"code","slug":"python/code","permalink":"http://thinkhard.tech/categories/python/code/"},{"name":"algorithm","slug":"python/code/algorithm","permalink":"http://thinkhard.tech/categories/python/code/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://thinkhard.tech/tags/python/"},{"name":"code","slug":"code","permalink":"http://thinkhard.tech/tags/code/"},{"name":"algorithm","slug":"algorithm","permalink":"http://thinkhard.tech/tags/algorithm/"}]},{"title":"python的webrtc库实现语音端点检测","slug":"python-vad","date":"2017-05-25T13:47:56.000Z","updated":"2019-04-04T10:10:23.767Z","comments":true,"path":"2017/05/25/python-vad/","link":"","permalink":"http://thinkhard.tech/2017/05/25/python-vad/","excerpt":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大. 但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段. 现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: * 语音转文字(ASR/STT) * 语义内容(NLU/NLP) * 文字转语音(TTS) 语音转文字(ASR/STT) 在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩","text":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大. 但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段. 现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: * 语音转文字(ASR/STT) * 语义内容(NLU/NLP) * 文字转语音(TTS) 语音转文字(ASR/STT) 在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩 python 端点检测 由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 唤醒词 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. * Kitt-AI : Snowboy * Sensory : Sensory 考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. * pyaudio: pip install pyaudio 可以从设备节点读取原始音频流数据,音频编码是PCM格式; * webrtcvad: pip install webrtcvad 检测判断一组语音数据是否为空语音; 当检测到持续时间长度 T1 vad检测都有语音活动,可以判定为语音起始; 当检测到持续时间长度 T2 vad检测都没有有语音活动,可以判定为语音结束; 完整程序代码可以从我的github下载 程序很简单,相信看一会儿就明白了 &#39;&#39;&#39; Requirements: + pyaudio - `pip install pyaudio` + py-webrtcvad - `pip install webrtcvad` &#39;&#39;&#39; import webrtcvad import collections import sys import signal import pyaudio from array import array from struct import pack import wave import time FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK_DURATION_MS = 30 # supports 10, 20 and 30 (ms) PADDING_DURATION_MS = 1500 # 1 sec jugement CHUNK_SIZE = int(RATE * CHUNK_DURATION_MS / 1000) # chunk to read CHUNK_BYTES = CHUNK_SIZE * 2 # 16bit = 2 bytes, PCM NUM_PADDING_CHUNKS = int(PADDING_DURATION_MS / CHUNK_DURATION_MS) # NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS) NUM_WINDOW_CHUNKS = int(400 / CHUNK_DURATION_MS) # 400 ms/ 30ms ge NUM_WINDOW_CHUNKS_END = NUM_WINDOW_CHUNKS * 2 START_OFFSET = int(NUM_WINDOW_CHUNKS * CHUNK_DURATION_MS * 0.5 * RATE) vad = webrtcvad.Vad(1) pa = pyaudio.PyAudio() stream = pa.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, start=False, # input_device_index=2, frames_per_buffer=CHUNK_SIZE) got_a_sentence = False leave = False def handle_int(sig, chunk): global leave, got_a_sentence leave = True got_a_sentence = True def record_to_file(path, data, sample_width): &quot;Records from the microphone and outputs the resulting data to &#39;path&#39;&quot; # sample_width, data = record() data = pack(&#39;&lt;&#39; + (&#39;h&#39; * len(data)), *data) wf = wave.open(path, &#39;wb&#39;) wf.setnchannels(1) wf.setsampwidth(sample_width) wf.setframerate(RATE) wf.writeframes(data) wf.close() def normalize(snd_data): &quot;Average the volume out&quot; MAXIMUM = 32767 # 16384 times = float(MAXIMUM) / max(abs(i) for i in snd_data) r = array(&#39;h&#39;) for i in snd_data: r.append(int(i * times)) return r signal.signal(signal.SIGINT, handle_int) while not leave: ring_buffer = collections.deque(maxlen=NUM_PADDING_CHUNKS) triggered = False voiced_frames = [] ring_buffer_flags = [0] * NUM_WINDOW_CHUNKS ring_buffer_index = 0 ring_buffer_flags_end = [0] * NUM_WINDOW_CHUNKS_END ring_buffer_index_end = 0 buffer_in = &#39;&#39; # WangS raw_data = array(&#39;h&#39;) index = 0 start_point = 0 StartTime = time.time() print(&quot;* recording: &quot;) stream.start_stream() while not got_a_sentence and not leave: chunk = stream.read(CHUNK_SIZE) # add WangS raw_data.extend(array(&#39;h&#39;, chunk)) index += CHUNK_SIZE TimeUse = time.time() - StartTime active = vad.is_speech(chunk, RATE) sys.stdout.write(&#39;1&#39; if active else &#39;_&#39;) ring_buffer_flags[ring_buffer_index] = 1 if active else 0 ring_buffer_index += 1 ring_buffer_index %= NUM_WINDOW_CHUNKS ring_buffer_flags_end[ring_buffer_index_end] = 1 if active else 0 ring_buffer_index_end += 1 ring_buffer_index_end %= NUM_WINDOW_CHUNKS_END # start point detection if not triggered: ring_buffer.append(chunk) num_voiced = sum(ring_buffer_flags) if num_voiced &gt; 0.8 * NUM_WINDOW_CHUNKS: sys.stdout.write(&#39; Open &#39;) triggered = True start_point = index - CHUNK_SIZE * 20 # start point # voiced_frames.extend(ring_buffer) ring_buffer.clear() # end point detection else: # voiced_frames.append(chunk) ring_buffer.append(chunk) num_unvoiced = NUM_WINDOW_CHUNKS_END - sum(ring_buffer_flags_end) if num_unvoiced &gt; 0.90 * NUM_WINDOW_CHUNKS_END or TimeUse &gt; 10: sys.stdout.write(&#39; Close &#39;) triggered = False got_a_sentence = True sys.stdout.flush() sys.stdout.write(&#39;\\n&#39;) # data = b&#39;&#39;.join(voiced_frames) stream.stop_stream() print(&quot;* done recording&quot;) got_a_sentence = False # write to file raw_data.reverse() for index in range(start_point): raw_data.pop() raw_data.reverse() raw_data = normalize(raw_data) record_to_file(&quot;recording.wav&quot;, raw_data, 2) leave = True stream.close() 程序运行方式sudo python vad.py qrcode_for_gh_3586401957c4_258.jpg Remove","categories":[{"name":"Python","slug":"Python","permalink":"http://thinkhard.tech/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://thinkhard.tech/categories/Python/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://thinkhard.tech/tags/Code/"}]},{"title":"Atom editor","slug":"Atom-editor","date":"2017-05-25T13:27:42.000Z","updated":"2019-04-04T10:10:23.685Z","comments":true,"path":"2017/05/25/Atom-editor/","link":"","permalink":"http://thinkhard.tech/2017/05/25/Atom-editor/","excerpt":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装 我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件 Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置 Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份 经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","text":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装 我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件 Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置 Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份 经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","categories":[{"name":"Tool","slug":"Tool","permalink":"http://thinkhard.tech/categories/Tool/"},{"name":"Linux","slug":"Tool/Linux","permalink":"http://thinkhard.tech/categories/Tool/Linux/"}],"tags":[{"name":"Editor","slug":"Editor","permalink":"http://thinkhard.tech/tags/Editor/"}]},{"title":"Cmake 模板","slug":"Cmake-tutorial","date":"2017-05-24T16:03:34.000Z","updated":"2019-04-04T10:10:23.685Z","comments":true,"path":"2017/05/25/Cmake-tutorial/","link":"","permalink":"http://thinkhard.tech/2017/05/25/Cmake-tutorial/","excerpt":"","text":"由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 &gt; * 更新CMakeList.txt文件 &gt; * 改变头文件位置，索引文件夹 &gt; * 上传新的gitlab CMakeList.txt模板 全局CMakeList.txt文件 123456789101112131415161718192021222324252627# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (aelos1s)# sys dirfind_package (Threads)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)add_subdirectory(lib)# 指定生成目标add_executable(aelos $&#123;DIR_SRCS&#125;)# 添加链接库# 生成链接库target_link_libraries(aelos aeloslib)# 多线程链接库target_link_libraries (aelos $&#123;CMAKE_THREAD_LIBS_INIT&#125;) 头文件库CMakeList.txt文件 123456# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 aeloslib 链接库add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;) 工程目录结构 the file structure is |----main.cpp #主程序 |----lib/ #*.cpp and *.h |----build/ #可执行文件生成文件夹 工程参考模板的github地址 https://github.com/wangshub/cmake","categories":[{"name":"Programming","slug":"Programming","permalink":"http://thinkhard.tech/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"http://thinkhard.tech/categories/Programming/Linux/"},{"name":"c/c++","slug":"Programming/Linux/c-c","permalink":"http://thinkhard.tech/categories/Programming/Linux/c-c/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://thinkhard.tech/tags/Code/"},{"name":"Linux","slug":"Linux","permalink":"http://thinkhard.tech/tags/Linux/"}]},{"title":"Hello World Github and Gitee","slug":"hello-world","date":"2017-04-14T13:28:12.000Z","updated":"2019-06-04T12:13:08.918Z","comments":true,"path":"2017/04/14/hello-world/","link":"","permalink":"http://thinkhard.tech/2017/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Setup pages. Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}